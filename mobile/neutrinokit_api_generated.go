// Code generated by falafel 0.9.2. DO NOT EDIT.
// source: ./neutrinokit_api_generated.go

//go:build neutrinorpc
// +build neutrinorpc

package lndmobile

import (
	"context"
	"net"

	"github.com/golang/protobuf/proto"
	"google.golang.org/grpc"

	"github.com/lightningnetwork/lnd/lnrpc/neutrinorpc"
)

// setNeutrinoKitDialOption sets the given method as the way
// to retrieve gprc options for the service.
func setNeutrinoKitDialOption(f func() ([]grpc.DialOption, error)) {
	serviceDialOptionsMtx.Lock()
	defer serviceDialOptionsMtx.Unlock()

	serviceDialOptions["NeutrinoKit"] = f
}

// applyNeutrinoKitDialOptions returns extra grpc options to
// use when calling the service.
func applyNeutrinoKitDialOptions() ([]grpc.DialOption, error) {
	serviceDialOptionsMtx.Lock()
	defer serviceDialOptionsMtx.Unlock()

	// First check the service options map, if there are any options
	// specific to this service.
	f, ok := serviceDialOptions["NeutrinoKit"]
	if ok {
		return f()
	}

	// Otherwise return the default options.
	return defaultDialOptions()
}

// getNeutrinoKitConn dials NeutrinoKit with the current dial options,
// and returns the grpc client connection.
func getNeutrinoKitConn() (*grpc.ClientConn, func(), error) {
	conn, err := lightningLis.Dial()
	if err != nil {
		return nil, nil, err
	}

	// Set up a custom dialer using the listener conn.
	dialer := func(context.Context, string) (net.Conn, error) {
		return conn, nil
	}

	// Create a dial options array.
	opts := []grpc.DialOption{
		grpc.WithContextDialer(dialer),
	}

	// Apply any extra server options.
	extraOpts, err := applyNeutrinoKitDialOptions()
	if err != nil {
		return nil, nil, err
	}

	opts = append(opts, extraOpts...)

	// As address we use "localhost" to mimic a local connection.
	address := "localhost"
	clientConn, err := grpc.Dial(address, opts...)
	if err != nil {
		conn.Close()
		return nil, nil, err
	}

	closeConn := func() {
		conn.Close()
	}

	return clientConn, closeConn, nil
}

// getNeutrinoKitClient returns a client connection to the server listening
// on lis.
func getNeutrinoKitClient() (neutrinorpc.NeutrinoKitClient, func(), error) {
	clientConn, closeConn, err := getNeutrinoKitConn()
	if err != nil {
		return nil, nil, err
	}
	client := neutrinorpc.NewNeutrinoKitClient(clientConn)
	return client, closeConn, nil
}

// Status returns the status of the light client neutrino instance,
// along with height and hash of the best block, and a list of connected
// peers.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func NeutrinoKitStatus(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &neutrinorpc.StatusRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getNeutrinoKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*neutrinorpc.StatusRequest)
			return client.Status(ctx, r)
		},
	}
	s.start(msg, callback)
}

// AddPeer adds a new peer that has already been connected to the server.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func NeutrinoKitAddPeer(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &neutrinorpc.AddPeerRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getNeutrinoKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*neutrinorpc.AddPeerRequest)
			return client.AddPeer(ctx, r)
		},
	}
	s.start(msg, callback)
}

// DisconnectPeer disconnects a peer by target address. Both outbound and
// inbound nodes will be searched for the target node. An error message will
// be returned if the peer was not found.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func NeutrinoKitDisconnectPeer(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &neutrinorpc.DisconnectPeerRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getNeutrinoKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*neutrinorpc.DisconnectPeerRequest)
			return client.DisconnectPeer(ctx, r)
		},
	}
	s.start(msg, callback)
}

// IsBanned returns true if the peer is banned, otherwise false.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func NeutrinoKitIsBanned(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &neutrinorpc.IsBannedRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getNeutrinoKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*neutrinorpc.IsBannedRequest)
			return client.IsBanned(ctx, r)
		},
	}
	s.start(msg, callback)
}

// GetBlockHeader returns a block header with a particular block hash.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func NeutrinoKitGetBlockHeader(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &neutrinorpc.GetBlockHeaderRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getNeutrinoKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*neutrinorpc.GetBlockHeaderRequest)
			return client.GetBlockHeader(ctx, r)
		},
	}
	s.start(msg, callback)
}

// GetBlock returns a block with a particular block hash.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func NeutrinoKitGetBlock(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &neutrinorpc.GetBlockRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getNeutrinoKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*neutrinorpc.GetBlockRequest)
			return client.GetBlock(ctx, r)
		},
	}
	s.start(msg, callback)
}

// GetCFilter returns a compact filter from a block.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func NeutrinoKitGetCFilter(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &neutrinorpc.GetCFilterRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getNeutrinoKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*neutrinorpc.GetCFilterRequest)
			return client.GetCFilter(ctx, r)
		},
	}
	s.start(msg, callback)
}

// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func NeutrinoKitGetBlockHash(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &neutrinorpc.GetBlockHashRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getNeutrinoKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*neutrinorpc.GetBlockHashRequest)
			return client.GetBlockHash(ctx, r)
		},
	}
	s.start(msg, callback)
}
