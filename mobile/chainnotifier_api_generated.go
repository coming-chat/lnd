// Code generated by falafel 0.9.2. DO NOT EDIT.
// source: ./chainnotifier_api_generated.go

//go:build chainrpc
// +build chainrpc

package lndmobile

import (
	"context"
	"net"

	"github.com/golang/protobuf/proto"
	"google.golang.org/grpc"

	"github.com/lightningnetwork/lnd/lnrpc/chainrpc"
)

// setChainNotifierDialOption sets the given method as the way
// to retrieve gprc options for the service.
func setChainNotifierDialOption(f func() ([]grpc.DialOption, error)) {
	serviceDialOptionsMtx.Lock()
	defer serviceDialOptionsMtx.Unlock()

	serviceDialOptions["ChainNotifier"] = f
}

// applyChainNotifierDialOptions returns extra grpc options to
// use when calling the service.
func applyChainNotifierDialOptions() ([]grpc.DialOption, error) {
	serviceDialOptionsMtx.Lock()
	defer serviceDialOptionsMtx.Unlock()

	// First check the service options map, if there are any options
	// specific to this service.
	f, ok := serviceDialOptions["ChainNotifier"]
	if ok {
		return f()
	}

	// Otherwise return the default options.
	return defaultDialOptions()
}

// getChainNotifierConn dials ChainNotifier with the current dial options,
// and returns the grpc client connection.
func getChainNotifierConn() (*grpc.ClientConn, func(), error) {
	conn, err := lightningLis.Dial()
	if err != nil {
		return nil, nil, err
	}

	// Set up a custom dialer using the listener conn.
	dialer := func(context.Context, string) (net.Conn, error) {
		return conn, nil
	}

	// Create a dial options array.
	opts := []grpc.DialOption{
		grpc.WithContextDialer(dialer),
	}

	// Apply any extra server options.
	extraOpts, err := applyChainNotifierDialOptions()
	if err != nil {
		return nil, nil, err
	}

	opts = append(opts, extraOpts...)

	// As address we use "localhost" to mimic a local connection.
	address := "localhost"
	clientConn, err := grpc.Dial(address, opts...)
	if err != nil {
		conn.Close()
		return nil, nil, err
	}

	closeConn := func() {
		conn.Close()
	}

	return clientConn, closeConn, nil
}

// getChainNotifierClient returns a client connection to the server listening
// on lis.
func getChainNotifierClient() (chainrpc.ChainNotifierClient, func(), error) {
	clientConn, closeConn, err := getChainNotifierConn()
	if err != nil {
		return nil, nil, err
	}
	client := chainrpc.NewChainNotifierClient(clientConn)
	return client, closeConn, nil
}

// RegisterConfirmationsNtfn is a synchronous response-streaming RPC that
// registers an intent for a client to be notified once a confirmation request
// has reached its required number of confirmations on-chain.
//
// A confirmation request must have a valid output script. It is also possible
// to give a transaction ID. If the transaction ID is not set, a notification
// is sent once the output script confirms. If the transaction ID is also set,
// a notification is sent once the output script confirms in the given
// transaction.
//
// NOTE: This method produces a stream of responses, and the receive stream can
// be called zero or more times. After EOF error is returned, no more responses
// will be produced.
func ChainNotifierRegisterConfirmationsNtfn(msg []byte, rStream RecvStream) {
	s := &readStreamHandler{
		newProto: func() proto.Message {
			return &chainrpc.ConfRequest{}
		},
		recvStream: func(ctx context.Context,
			req proto.Message) (*receiver, func(), error) {

			// Get the gRPC client.
			client, closeClient, err := getChainNotifierClient()
			if err != nil {
				return nil, nil, err
			}

			r := req.(*chainrpc.ConfRequest)
			stream, err := client.RegisterConfirmationsNtfn(ctx, r)
			if err != nil {
				closeClient()
				return nil, nil, err
			}
			return &receiver{
				recv: func() (proto.Message, error) {
					return stream.Recv()
				},
			}, closeClient, nil
		},
	}
	s.start(msg, rStream)
}

// RegisterSpendNtfn is a synchronous response-streaming RPC that registers an
// intent for a client to be notification once a spend request has been spent
// by a transaction that has confirmed on-chain.
//
// A client can specify whether the spend request should be for a particular
// outpoint  or for an output script by specifying a zero outpoint.
//
// NOTE: This method produces a stream of responses, and the receive stream can
// be called zero or more times. After EOF error is returned, no more responses
// will be produced.
func ChainNotifierRegisterSpendNtfn(msg []byte, rStream RecvStream) {
	s := &readStreamHandler{
		newProto: func() proto.Message {
			return &chainrpc.SpendRequest{}
		},
		recvStream: func(ctx context.Context,
			req proto.Message) (*receiver, func(), error) {

			// Get the gRPC client.
			client, closeClient, err := getChainNotifierClient()
			if err != nil {
				return nil, nil, err
			}

			r := req.(*chainrpc.SpendRequest)
			stream, err := client.RegisterSpendNtfn(ctx, r)
			if err != nil {
				closeClient()
				return nil, nil, err
			}
			return &receiver{
				recv: func() (proto.Message, error) {
					return stream.Recv()
				},
			}, closeClient, nil
		},
	}
	s.start(msg, rStream)
}

// RegisterBlockEpochNtfn is a synchronous response-streaming RPC that
// registers an intent for a client to be notified of blocks in the chain. The
// stream will return a hash and height tuple of a block for each new/stale
// block in the chain. It is the client's responsibility to determine whether
// the tuple returned is for a new or stale block in the chain.
//
// A client can also request a historical backlog of blocks from a particular
// point. This allows clients to be idempotent by ensuring that they do not
// missing processing a single block within the chain.
//
// NOTE: This method produces a stream of responses, and the receive stream can
// be called zero or more times. After EOF error is returned, no more responses
// will be produced.
func ChainNotifierRegisterBlockEpochNtfn(msg []byte, rStream RecvStream) {
	s := &readStreamHandler{
		newProto: func() proto.Message {
			return &chainrpc.BlockEpoch{}
		},
		recvStream: func(ctx context.Context,
			req proto.Message) (*receiver, func(), error) {

			// Get the gRPC client.
			client, closeClient, err := getChainNotifierClient()
			if err != nil {
				return nil, nil, err
			}

			r := req.(*chainrpc.BlockEpoch)
			stream, err := client.RegisterBlockEpochNtfn(ctx, r)
			if err != nil {
				closeClient()
				return nil, nil, err
			}
			return &receiver{
				recv: func() (proto.Message, error) {
					return stream.Recv()
				},
			}, closeClient, nil
		},
	}
	s.start(msg, rStream)
}
