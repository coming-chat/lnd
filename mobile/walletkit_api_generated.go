// Code generated by falafel 0.9.2. DO NOT EDIT.
// source: ./walletkit_api_generated.go

//go:build walletrpc
// +build walletrpc

package lndmobile

import (
	"context"
	"net"

	"github.com/golang/protobuf/proto"
	"google.golang.org/grpc"

	"github.com/lightningnetwork/lnd/lnrpc/signrpc"
	"github.com/lightningnetwork/lnd/lnrpc/walletrpc"
)

// setWalletKitDialOption sets the given method as the way
// to retrieve gprc options for the service.
func setWalletKitDialOption(f func() ([]grpc.DialOption, error)) {
	serviceDialOptionsMtx.Lock()
	defer serviceDialOptionsMtx.Unlock()

	serviceDialOptions["WalletKit"] = f
}

// applyWalletKitDialOptions returns extra grpc options to
// use when calling the service.
func applyWalletKitDialOptions() ([]grpc.DialOption, error) {
	serviceDialOptionsMtx.Lock()
	defer serviceDialOptionsMtx.Unlock()

	// First check the service options map, if there are any options
	// specific to this service.
	f, ok := serviceDialOptions["WalletKit"]
	if ok {
		return f()
	}

	// Otherwise return the default options.
	return defaultDialOptions()
}

// getWalletKitConn dials WalletKit with the current dial options,
// and returns the grpc client connection.
func getWalletKitConn() (*grpc.ClientConn, func(), error) {
	conn, err := lightningLis.Dial()
	if err != nil {
		return nil, nil, err
	}

	// Set up a custom dialer using the listener conn.
	dialer := func(context.Context, string) (net.Conn, error) {
		return conn, nil
	}

	// Create a dial options array.
	opts := []grpc.DialOption{
		grpc.WithContextDialer(dialer),
	}

	// Apply any extra server options.
	extraOpts, err := applyWalletKitDialOptions()
	if err != nil {
		return nil, nil, err
	}

	opts = append(opts, extraOpts...)

	// As address we use "localhost" to mimic a local connection.
	address := "localhost"
	clientConn, err := grpc.Dial(address, opts...)
	if err != nil {
		conn.Close()
		return nil, nil, err
	}

	closeConn := func() {
		conn.Close()
	}

	return clientConn, closeConn, nil
}

// getWalletKitClient returns a client connection to the server listening
// on lis.
func getWalletKitClient() (walletrpc.WalletKitClient, func(), error) {
	clientConn, closeConn, err := getWalletKitConn()
	if err != nil {
		return nil, nil, err
	}
	client := walletrpc.NewWalletKitClient(clientConn)
	return client, closeConn, nil
}

// ListUnspent returns a list of all utxos spendable by the wallet with a
// number of confirmations between the specified minimum and maximum. By
// default, all utxos are listed. To list only the unconfirmed utxos, set
// the unconfirmed_only to true.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func WalletKitListUnspent(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.ListUnspentRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*walletrpc.ListUnspentRequest)
			return client.ListUnspent(ctx, r)
		},
	}
	s.start(msg, callback)
}

// LeaseOutput locks an output to the given ID, preventing it from being
// available for any future coin selection attempts. The absolute time of the
// lock's expiration is returned. The expiration of the lock can be extended by
// successive invocations of this RPC. Outputs can be unlocked before their
// expiration through `ReleaseOutput`.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func WalletKitLeaseOutput(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.LeaseOutputRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*walletrpc.LeaseOutputRequest)
			return client.LeaseOutput(ctx, r)
		},
	}
	s.start(msg, callback)
}

// ReleaseOutput unlocks an output, allowing it to be available for coin
// selection if it remains unspent. The ID should match the one used to
// originally lock the output.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func WalletKitReleaseOutput(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.ReleaseOutputRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*walletrpc.ReleaseOutputRequest)
			return client.ReleaseOutput(ctx, r)
		},
	}
	s.start(msg, callback)
}

// ListLeases lists all currently locked utxos.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func WalletKitListLeases(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.ListLeasesRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*walletrpc.ListLeasesRequest)
			return client.ListLeases(ctx, r)
		},
	}
	s.start(msg, callback)
}

// DeriveNextKey attempts to derive the *next* key within the key family
// (account in BIP43) specified. This method should return the next external
// child within this branch.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func WalletKitDeriveNextKey(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.KeyReq{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*walletrpc.KeyReq)
			return client.DeriveNextKey(ctx, r)
		},
	}
	s.start(msg, callback)
}

// DeriveKey attempts to derive an arbitrary key specified by the passed
// KeyLocator.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func WalletKitDeriveKey(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &signrpc.KeyLocator{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*signrpc.KeyLocator)
			return client.DeriveKey(ctx, r)
		},
	}
	s.start(msg, callback)
}

// NextAddr returns the next unused address within the wallet.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func WalletKitNextAddr(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.AddrRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*walletrpc.AddrRequest)
			return client.NextAddr(ctx, r)
		},
	}
	s.start(msg, callback)
}

// GetTransaction returns details for a transaction found in the wallet.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func WalletKitGetTransaction(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.GetTransactionRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*walletrpc.GetTransactionRequest)
			return client.GetTransaction(ctx, r)
		},
	}
	s.start(msg, callback)
}

// ListAccounts retrieves all accounts belonging to the wallet by default. A
// name and key scope filter can be provided to filter through all of the
// wallet accounts and return only those matching.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func WalletKitListAccounts(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.ListAccountsRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*walletrpc.ListAccountsRequest)
			return client.ListAccounts(ctx, r)
		},
	}
	s.start(msg, callback)
}

// RequiredReserve returns the minimum amount of satoshis that should be kept
// in the wallet in order to fee bump anchor channels if necessary. The value
// scales with the number of public anchor channels but is capped at a maximum.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func WalletKitRequiredReserve(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.RequiredReserveRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*walletrpc.RequiredReserveRequest)
			return client.RequiredReserve(ctx, r)
		},
	}
	s.start(msg, callback)
}

// ListAddresses retrieves all the addresses along with their balance. An
// account name filter can be provided to filter through all of the
// wallet accounts and return the addresses of only those matching.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func WalletKitListAddresses(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.ListAddressesRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*walletrpc.ListAddressesRequest)
			return client.ListAddresses(ctx, r)
		},
	}
	s.start(msg, callback)
}

// SignMessageWithAddr returns the compact signature (base64 encoded) created
// with the private key of the provided address. This requires the address
// to be solely based on a public key lock (no scripts). Obviously the internal
// lnd wallet has to possess the private key of the address otherwise
// an error is returned.
//
// This method aims to provide full compatibility with the bitcoin-core and
// btcd implementation. Bitcoin-core's algorithm is not specified in a
// BIP and only applicable for legacy addresses. This method enhances the
// signing for additional address types: P2WKH, NP2WKH, P2TR.
// For P2TR addresses this represents a special case. ECDSA is used to create
// a compact signature which makes the public key of the signature recoverable.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func WalletKitSignMessageWithAddr(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.SignMessageWithAddrRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*walletrpc.SignMessageWithAddrRequest)
			return client.SignMessageWithAddr(ctx, r)
		},
	}
	s.start(msg, callback)
}

// VerifyMessageWithAddr returns the validity and the recovered public key of
// the provided compact signature (base64 encoded). The verification is
// twofold. First the validity of the signature itself is checked and then
// it is verified that the recovered public key of the signature equals
// the public key of the provided address. There is no dependence on the
// private key of the address therefore also external addresses are allowed
// to verify signatures.
// Supported address types are P2PKH, P2WKH, NP2WKH, P2TR.
//
// This method is the counterpart of the related signing method
// (SignMessageWithAddr) and aims to provide full compatibility to
// bitcoin-core's implementation. Although bitcoin-core/btcd only provide
// this functionality for legacy addresses this function enhances it to
// the address types: P2PKH, P2WKH, NP2WKH, P2TR.
//
// The verification for P2TR addresses is a special case and requires the
// ECDSA compact signature to compare the reovered public key to the internal
// taproot key. The compact ECDSA signature format was used because there
// are still no known compact signature schemes for schnorr signatures.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func WalletKitVerifyMessageWithAddr(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.VerifyMessageWithAddrRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*walletrpc.VerifyMessageWithAddrRequest)
			return client.VerifyMessageWithAddr(ctx, r)
		},
	}
	s.start(msg, callback)
}

// ImportAccount imports an account backed by an account extended public key.
// The master key fingerprint denotes the fingerprint of the root key
// corresponding to the account public key (also known as the key with
// derivation path m/). This may be required by some hardware wallets for
// proper identification and signing.
//
// The address type can usually be inferred from the key's version, but may be
// required for certain keys to map them into the proper scope.
//
// For BIP-0044 keys, an address type must be specified as we intend to not
// support importing BIP-0044 keys into the wallet using the legacy
// pay-to-pubkey-hash (P2PKH) scheme. A nested witness address type will force
// the standard BIP-0049 derivation scheme, while a witness address type will
// force the standard BIP-0084 derivation scheme.
//
// For BIP-0049 keys, an address type must also be specified to make a
// distinction between the standard BIP-0049 address schema (nested witness
// pubkeys everywhere) and our own BIP-0049Plus address schema (nested pubkeys
// externally, witness pubkeys internally).
//
// NOTE: Events (deposits/spends) for keys derived from an account will only be
// detected by lnd if they happen after the import. Rescans to detect past
// events will be supported later on.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func WalletKitImportAccount(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.ImportAccountRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*walletrpc.ImportAccountRequest)
			return client.ImportAccount(ctx, r)
		},
	}
	s.start(msg, callback)
}

// ImportPublicKey imports a public key as watch-only into the wallet. The
// public key is converted into a simple address of the given type and that
// address script is watched on chain. For Taproot keys, this will only watch
// the BIP-0086 style output script. Use ImportTapscript for more advanced key
// spend or script spend outputs.
//
// NOTE: Events (deposits/spends) for a key will only be detected by lnd if
// they happen after the import. Rescans to detect past events will be
// supported later on.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func WalletKitImportPublicKey(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.ImportPublicKeyRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*walletrpc.ImportPublicKeyRequest)
			return client.ImportPublicKey(ctx, r)
		},
	}
	s.start(msg, callback)
}

// ImportTapscript imports a Taproot script and internal key and adds the
// resulting Taproot output key as a watch-only output script into the wallet.
// For BIP-0086 style Taproot keys (no root hash commitment and no script spend
// path) use ImportPublicKey.
//
// NOTE: Events (deposits/spends) for a key will only be detected by lnd if
// they happen after the import. Rescans to detect past events will be
// supported later on.
//
// NOTE: Taproot keys imported through this RPC currently _cannot_ be used for
// funding PSBTs. Only tracking the balance and UTXOs is currently supported.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func WalletKitImportTapscript(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.ImportTapscriptRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*walletrpc.ImportTapscriptRequest)
			return client.ImportTapscript(ctx, r)
		},
	}
	s.start(msg, callback)
}

// PublishTransaction attempts to publish the passed transaction to the
// network. Once this returns without an error, the wallet will continually
// attempt to re-broadcast the transaction on start up, until it enters the
// chain.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func WalletKitPublishTransaction(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.Transaction{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*walletrpc.Transaction)
			return client.PublishTransaction(ctx, r)
		},
	}
	s.start(msg, callback)
}

// RemoveTransaction attempts to remove the provided transaction from the
// internal transaction store of the wallet.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func WalletKitRemoveTransaction(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.GetTransactionRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*walletrpc.GetTransactionRequest)
			return client.RemoveTransaction(ctx, r)
		},
	}
	s.start(msg, callback)
}

// SendOutputs is similar to the existing sendmany call in Bitcoind, and
// allows the caller to create a transaction that sends to several outputs at
// once. This is ideal when wanting to batch create a set of transactions.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func WalletKitSendOutputs(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.SendOutputsRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*walletrpc.SendOutputsRequest)
			return client.SendOutputs(ctx, r)
		},
	}
	s.start(msg, callback)
}

// EstimateFee attempts to query the internal fee estimator of the wallet to
// determine the fee (in sat/kw) to attach to a transaction in order to
// achieve the confirmation target.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func WalletKitEstimateFee(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.EstimateFeeRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*walletrpc.EstimateFeeRequest)
			return client.EstimateFee(ctx, r)
		},
	}
	s.start(msg, callback)
}

// PendingSweeps returns lists of on-chain outputs that lnd is currently
// attempting to sweep within its central batching engine. Outputs with similar
// fee rates are batched together in order to sweep them within a single
// transaction.
//
// NOTE: Some of the fields within PendingSweepsRequest are not guaranteed to
// remain supported. This is an advanced API that depends on the internals of
// the UtxoSweeper, so things may change.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func WalletKitPendingSweeps(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.PendingSweepsRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*walletrpc.PendingSweepsRequest)
			return client.PendingSweeps(ctx, r)
		},
	}
	s.start(msg, callback)
}

// BumpFee is an endpoint that allows users to interact with lnd's sweeper
// directly. It takes an outpoint from an unconfirmed transaction and sends it
// to the sweeper for potential fee bumping. Depending on whether the outpoint
// has been registered in the sweeper (an existing input, e.g., an anchor
// output) or not (a new input, e.g., an unconfirmed wallet utxo), this will
// either be an RBF or CPFP attempt.
//
// When receiving an input, lndâ€™s sweeper needs to understand its time
// sensitivity to make economical fee bumps - internally a fee function is
// created using the deadline and budget to guide the process. When the
// deadline is approaching, the fee function will increase the fee rate and
// perform an RBF.
//
// When a force close happens, all the outputs from the force closing
// transaction will be registered in the sweeper. The sweeper will then handle
// the creation, publish, and fee bumping of the sweeping transactions.
// Everytime a new block comes in, unless the sweeping transaction is
// confirmed, an RBF is attempted. To interfere with this automatic process,
// users can use BumpFee to specify customized fee rate, budget, deadline, and
// whether the sweep should happen immediately. It's recommended to call
// `ListSweeps` to understand the shape of the existing sweeping transaction
// first - depending on the number of inputs in this transaction, the RBF
// requirements can be quite different.
//
// This RPC also serves useful when wanting to perform a Child-Pays-For-Parent
// (CPFP), where the child transaction pays for its parent's fee. This can be
// done by specifying an outpoint within the low fee transaction that is under
// the control of the wallet.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func WalletKitBumpFee(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.BumpFeeRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*walletrpc.BumpFeeRequest)
			return client.BumpFee(ctx, r)
		},
	}
	s.start(msg, callback)
}

// ListSweeps returns a list of the sweep transactions our node has produced.
// Note that these sweeps may not be confirmed yet, as we record sweeps on
// broadcast, not confirmation.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func WalletKitListSweeps(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.ListSweepsRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*walletrpc.ListSweepsRequest)
			return client.ListSweeps(ctx, r)
		},
	}
	s.start(msg, callback)
}

// LabelTransaction adds a label to a transaction. If the transaction already
// has a label the call will fail unless the overwrite bool is set. This will
// overwrite the existing transaction label. Labels must not be empty, and
// cannot exceed 500 characters.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func WalletKitLabelTransaction(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.LabelTransactionRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*walletrpc.LabelTransactionRequest)
			return client.LabelTransaction(ctx, r)
		},
	}
	s.start(msg, callback)
}

// FundPsbt creates a fully populated PSBT that contains enough inputs to fund
// the outputs specified in the template. There are three ways a user can
// specify what we call the template (a list of inputs and outputs to use in
// the PSBT): Either as a PSBT packet directly with no coin selection (using
// the legacy "psbt" field), a PSBT with advanced coin selection support (using
// the new "coin_select" field) or as a raw RPC message (using the "raw"
// field).
// The legacy "psbt" and "raw" modes, the following restrictions apply:
// 1. If there are no inputs specified in the template, coin selection is
// performed automatically.
// 2. If the template does contain any inputs, it is assumed that full
// coin selection happened externally and no additional inputs are added. If
// the specified inputs aren't enough to fund the outputs with the given fee
// rate, an error is returned.
//
// The new "coin_select" mode does not have these restrictions and allows the
// user to specify a PSBT with inputs and outputs and still perform coin
// selection on top of that.
// For all modes this RPC requires any inputs that are specified to be locked
// by the user (if they belong to this node in the first place).
//
// After either selecting or verifying the inputs, all input UTXOs are locked
// with an internal app ID.
//
// NOTE: If this method returns without an error, it is the caller's
// responsibility to either spend the locked UTXOs (by finalizing and then
// publishing the transaction) or to unlock/release the locked UTXOs in case of
// an error on the caller's side.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func WalletKitFundPsbt(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.FundPsbtRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*walletrpc.FundPsbtRequest)
			return client.FundPsbt(ctx, r)
		},
	}
	s.start(msg, callback)
}

// SignPsbt expects a partial transaction with all inputs and outputs fully
// declared and tries to sign all unsigned inputs that have all required fields
// (UTXO information, BIP32 derivation information, witness or sig scripts)
// set.
// If no error is returned, the PSBT is ready to be given to the next signer or
// to be finalized if lnd was the last signer.
//
// NOTE: This RPC only signs inputs (and only those it can sign), it does not
// perform any other tasks (such as coin selection, UTXO locking or
// input/output/fee value validation, PSBT finalization). Any input that is
// incomplete will be skipped.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func WalletKitSignPsbt(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.SignPsbtRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*walletrpc.SignPsbtRequest)
			return client.SignPsbt(ctx, r)
		},
	}
	s.start(msg, callback)
}

// FinalizePsbt expects a partial transaction with all inputs and outputs fully
// declared and tries to sign all inputs that belong to the wallet. Lnd must be
// the last signer of the transaction. That means, if there are any unsigned
// non-witness inputs or inputs without UTXO information attached or inputs
// without witness data that do not belong to lnd's wallet, this method will
// fail. If no error is returned, the PSBT is ready to be extracted and the
// final TX within to be broadcast.
//
// NOTE: This method does NOT publish the transaction once finalized. It is the
// caller's responsibility to either publish the transaction on success or
// unlock/release any locked UTXOs in case of an error in this method.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func WalletKitFinalizePsbt(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &walletrpc.FinalizePsbtRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getWalletKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*walletrpc.FinalizePsbtRequest)
			return client.FinalizePsbt(ctx, r)
		},
	}
	s.start(msg, callback)
}
