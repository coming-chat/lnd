// Code generated by falafel 0.9.2. DO NOT EDIT.
// source: ./router_api_generated.go

//go:build routerrpc
// +build routerrpc

package lndmobile

import (
	"context"
	"net"

	"github.com/golang/protobuf/proto"
	"google.golang.org/grpc"

	"github.com/lightningnetwork/lnd/lnrpc/routerrpc"
)

// setRouterDialOption sets the given method as the way
// to retrieve gprc options for the service.
func setRouterDialOption(f func() ([]grpc.DialOption, error)) {
	serviceDialOptionsMtx.Lock()
	defer serviceDialOptionsMtx.Unlock()

	serviceDialOptions["Router"] = f
}

// applyRouterDialOptions returns extra grpc options to
// use when calling the service.
func applyRouterDialOptions() ([]grpc.DialOption, error) {
	serviceDialOptionsMtx.Lock()
	defer serviceDialOptionsMtx.Unlock()

	// First check the service options map, if there are any options
	// specific to this service.
	f, ok := serviceDialOptions["Router"]
	if ok {
		return f()
	}

	// Otherwise return the default options.
	return defaultDialOptions()
}

// getRouterConn dials Router with the current dial options,
// and returns the grpc client connection.
func getRouterConn() (*grpc.ClientConn, func(), error) {
	conn, err := lightningLis.Dial()
	if err != nil {
		return nil, nil, err
	}

	// Set up a custom dialer using the listener conn.
	dialer := func(context.Context, string) (net.Conn, error) {
		return conn, nil
	}

	// Create a dial options array.
	opts := []grpc.DialOption{
		grpc.WithContextDialer(dialer),
	}

	// Apply any extra server options.
	extraOpts, err := applyRouterDialOptions()
	if err != nil {
		return nil, nil, err
	}

	opts = append(opts, extraOpts...)

	// As address we use "localhost" to mimic a local connection.
	address := "localhost"
	clientConn, err := grpc.Dial(address, opts...)
	if err != nil {
		conn.Close()
		return nil, nil, err
	}

	closeConn := func() {
		conn.Close()
	}

	return clientConn, closeConn, nil
}

// getRouterClient returns a client connection to the server listening
// on lis.
func getRouterClient() (routerrpc.RouterClient, func(), error) {
	clientConn, closeConn, err := getRouterConn()
	if err != nil {
		return nil, nil, err
	}
	client := routerrpc.NewRouterClient(clientConn)
	return client, closeConn, nil
}

// SendPaymentV2 attempts to route a payment described by the passed
// PaymentRequest to the final destination. The call returns a stream of
// payment updates. When using this RPC, make sure to set a fee limit, as the
// default routing fee limit is 0 sats. Without a non-zero fee limit only
// routes without fees will be attempted which often fails with
// FAILURE_REASON_NO_ROUTE.
//
// NOTE: This method produces a stream of responses, and the receive stream can
// be called zero or more times. After EOF error is returned, no more responses
// will be produced.
func RouterSendPaymentV2(msg []byte, rStream RecvStream) {
	s := &readStreamHandler{
		newProto: func() proto.Message {
			return &routerrpc.SendPaymentRequest{}
		},
		recvStream: func(ctx context.Context,
			req proto.Message) (*receiver, func(), error) {

			// Get the gRPC client.
			client, closeClient, err := getRouterClient()
			if err != nil {
				return nil, nil, err
			}

			r := req.(*routerrpc.SendPaymentRequest)
			stream, err := client.SendPaymentV2(ctx, r)
			if err != nil {
				closeClient()
				return nil, nil, err
			}
			return &receiver{
				recv: func() (proto.Message, error) {
					return stream.Recv()
				},
			}, closeClient, nil
		},
	}
	s.start(msg, rStream)
}

// TrackPaymentV2 returns an update stream for the payment identified by the
// payment hash.
//
// NOTE: This method produces a stream of responses, and the receive stream can
// be called zero or more times. After EOF error is returned, no more responses
// will be produced.
func RouterTrackPaymentV2(msg []byte, rStream RecvStream) {
	s := &readStreamHandler{
		newProto: func() proto.Message {
			return &routerrpc.TrackPaymentRequest{}
		},
		recvStream: func(ctx context.Context,
			req proto.Message) (*receiver, func(), error) {

			// Get the gRPC client.
			client, closeClient, err := getRouterClient()
			if err != nil {
				return nil, nil, err
			}

			r := req.(*routerrpc.TrackPaymentRequest)
			stream, err := client.TrackPaymentV2(ctx, r)
			if err != nil {
				closeClient()
				return nil, nil, err
			}
			return &receiver{
				recv: func() (proto.Message, error) {
					return stream.Recv()
				},
			}, closeClient, nil
		},
	}
	s.start(msg, rStream)
}

// TrackPayments returns an update stream for every payment that is not in a
// terminal state. Note that if payments are in-flight while starting a new
// subscription, the start of the payment stream could produce out-of-order
// and/or duplicate events. In order to get updates for every in-flight
// payment attempt make sure to subscribe to this method before initiating any
// payments.
//
// NOTE: This method produces a stream of responses, and the receive stream can
// be called zero or more times. After EOF error is returned, no more responses
// will be produced.
func RouterTrackPayments(msg []byte, rStream RecvStream) {
	s := &readStreamHandler{
		newProto: func() proto.Message {
			return &routerrpc.TrackPaymentsRequest{}
		},
		recvStream: func(ctx context.Context,
			req proto.Message) (*receiver, func(), error) {

			// Get the gRPC client.
			client, closeClient, err := getRouterClient()
			if err != nil {
				return nil, nil, err
			}

			r := req.(*routerrpc.TrackPaymentsRequest)
			stream, err := client.TrackPayments(ctx, r)
			if err != nil {
				closeClient()
				return nil, nil, err
			}
			return &receiver{
				recv: func() (proto.Message, error) {
					return stream.Recv()
				},
			}, closeClient, nil
		},
	}
	s.start(msg, rStream)
}

// EstimateRouteFee allows callers to obtain a lower bound w.r.t how much it
// may cost to send an HTLC to the target end destination.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func RouterEstimateRouteFee(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &routerrpc.RouteFeeRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getRouterClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*routerrpc.RouteFeeRequest)
			return client.EstimateRouteFee(ctx, r)
		},
	}
	s.start(msg, callback)
}

// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func RouterSendToRoute(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &routerrpc.SendToRouteRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getRouterClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*routerrpc.SendToRouteRequest)
			return client.SendToRoute(ctx, r)
		},
	}
	s.start(msg, callback)
}

// SendToRouteV2 attempts to make a payment via the specified route. This
// method differs from SendPayment in that it allows users to specify a full
// route manually. This can be used for things like rebalancing, and atomic
// swaps.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func RouterSendToRouteV2(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &routerrpc.SendToRouteRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getRouterClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*routerrpc.SendToRouteRequest)
			return client.SendToRouteV2(ctx, r)
		},
	}
	s.start(msg, callback)
}

// ResetMissionControl clears all mission control state and starts with a clean
// slate.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func RouterResetMissionControl(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &routerrpc.ResetMissionControlRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getRouterClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*routerrpc.ResetMissionControlRequest)
			return client.ResetMissionControl(ctx, r)
		},
	}
	s.start(msg, callback)
}

// QueryMissionControl exposes the internal mission control state to callers.
// It is a development feature.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func RouterQueryMissionControl(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &routerrpc.QueryMissionControlRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getRouterClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*routerrpc.QueryMissionControlRequest)
			return client.QueryMissionControl(ctx, r)
		},
	}
	s.start(msg, callback)
}

// XImportMissionControl is an experimental API that imports the state provided
// to the internal mission control's state, using all results which are more
// recent than our existing values. These values will only be imported
// in-memory, and will not be persisted across restarts.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func RouterXImportMissionControl(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &routerrpc.XImportMissionControlRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getRouterClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*routerrpc.XImportMissionControlRequest)
			return client.XImportMissionControl(ctx, r)
		},
	}
	s.start(msg, callback)
}

// GetMissionControlConfig returns mission control's current config.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func RouterGetMissionControlConfig(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &routerrpc.GetMissionControlConfigRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getRouterClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*routerrpc.GetMissionControlConfigRequest)
			return client.GetMissionControlConfig(ctx, r)
		},
	}
	s.start(msg, callback)
}

// SetMissionControlConfig will set mission control's config, if the config
// provided is valid.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func RouterSetMissionControlConfig(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &routerrpc.SetMissionControlConfigRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getRouterClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*routerrpc.SetMissionControlConfigRequest)
			return client.SetMissionControlConfig(ctx, r)
		},
	}
	s.start(msg, callback)
}

// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func RouterQueryProbability(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &routerrpc.QueryProbabilityRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getRouterClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*routerrpc.QueryProbabilityRequest)
			return client.QueryProbability(ctx, r)
		},
	}
	s.start(msg, callback)
}

// BuildRoute builds a fully specified route based on a list of hop public
// keys. It retrieves the relevant channel policies from the graph in order to
// calculate the correct fees and time locks.
// Note that LND will use its default final_cltv_delta if no value is supplied.
// Make sure to add the correct final_cltv_delta depending on the invoice
// restriction. Moreover the caller has to make sure to provide the
// payment_addr if the route is paying an invoice which signaled it.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func RouterBuildRoute(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &routerrpc.BuildRouteRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getRouterClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*routerrpc.BuildRouteRequest)
			return client.BuildRoute(ctx, r)
		},
	}
	s.start(msg, callback)
}

// SubscribeHtlcEvents creates a uni-directional stream from the server to
// the client which delivers a stream of htlc events.
//
// NOTE: This method produces a stream of responses, and the receive stream can
// be called zero or more times. After EOF error is returned, no more responses
// will be produced.
func RouterSubscribeHtlcEvents(msg []byte, rStream RecvStream) {
	s := &readStreamHandler{
		newProto: func() proto.Message {
			return &routerrpc.SubscribeHtlcEventsRequest{}
		},
		recvStream: func(ctx context.Context,
			req proto.Message) (*receiver, func(), error) {

			// Get the gRPC client.
			client, closeClient, err := getRouterClient()
			if err != nil {
				return nil, nil, err
			}

			r := req.(*routerrpc.SubscribeHtlcEventsRequest)
			stream, err := client.SubscribeHtlcEvents(ctx, r)
			if err != nil {
				closeClient()
				return nil, nil, err
			}
			return &receiver{
				recv: func() (proto.Message, error) {
					return stream.Recv()
				},
			}, closeClient, nil
		},
	}
	s.start(msg, rStream)
}

// NOTE: This method produces a stream of responses, and the receive stream can
// be called zero or more times. After EOF error is returned, no more responses
// will be produced.
func RouterSendPayment(msg []byte, rStream RecvStream) {
	s := &readStreamHandler{
		newProto: func() proto.Message {
			return &routerrpc.SendPaymentRequest{}
		},
		recvStream: func(ctx context.Context,
			req proto.Message) (*receiver, func(), error) {

			// Get the gRPC client.
			client, closeClient, err := getRouterClient()
			if err != nil {
				return nil, nil, err
			}

			r := req.(*routerrpc.SendPaymentRequest)
			stream, err := client.SendPayment(ctx, r)
			if err != nil {
				closeClient()
				return nil, nil, err
			}
			return &receiver{
				recv: func() (proto.Message, error) {
					return stream.Recv()
				},
			}, closeClient, nil
		},
	}
	s.start(msg, rStream)
}

// NOTE: This method produces a stream of responses, and the receive stream can
// be called zero or more times. After EOF error is returned, no more responses
// will be produced.
func RouterTrackPayment(msg []byte, rStream RecvStream) {
	s := &readStreamHandler{
		newProto: func() proto.Message {
			return &routerrpc.TrackPaymentRequest{}
		},
		recvStream: func(ctx context.Context,
			req proto.Message) (*receiver, func(), error) {

			// Get the gRPC client.
			client, closeClient, err := getRouterClient()
			if err != nil {
				return nil, nil, err
			}

			r := req.(*routerrpc.TrackPaymentRequest)
			stream, err := client.TrackPayment(ctx, r)
			if err != nil {
				closeClient()
				return nil, nil, err
			}
			return &receiver{
				recv: func() (proto.Message, error) {
					return stream.Recv()
				},
			}, closeClient, nil
		},
	}
	s.start(msg, rStream)
}

// HtlcInterceptor dispatches a bi-directional streaming RPC in which
// Forwarded HTLC requests are sent to the client and the client responds with
// a boolean that tells LND if this htlc should be intercepted.
// In case of interception, the htlc can be either settled, cancelled or
// resumed later by using the ResolveHoldForward endpoint.
//
// NOTE: This method produces a stream of responses, and the receive stream can
// be called zero or more times. After EOF error is returned, no more responses
// will be produced. The send stream can accept zero or more requests before it
// is closed.
func RouterHtlcInterceptor(rStream RecvStream) (SendStream, error) {
	b := &biStreamHandler{
		newProto: func() proto.Message {
			return &routerrpc.ForwardHtlcInterceptResponse{}
		},
		biStream: func(ctx context.Context) (*receiver, *sender, func(), error) {

			// Get the gRPC client.
			client, closeClient, err := getRouterClient()
			if err != nil {
				return nil, nil, nil, err
			}

			stream, err := client.HtlcInterceptor(ctx)
			if err != nil {
				closeClient()
				return nil, nil, nil, err
			}
			return &receiver{
					recv: func() (proto.Message, error) {
						return stream.Recv()
					},
				},
				&sender{
					send: func(req proto.Message) error {
						r := req.(*routerrpc.ForwardHtlcInterceptResponse)
						return stream.Send(r)
					},
					closeStream: stream.CloseSend,
				}, closeClient, nil
		},
	}
	return b.start(rStream)
}

// UpdateChanStatus attempts to manually set the state of a channel
// (enabled, disabled, or auto). A manual "disable" request will cause the
// channel to stay disabled until a subsequent manual request of either
// "enable" or "auto".
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func RouterUpdateChanStatus(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &routerrpc.UpdateChanStatusRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getRouterClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*routerrpc.UpdateChanStatusRequest)
			return client.UpdateChanStatus(ctx, r)
		},
	}
	s.start(msg, callback)
}
