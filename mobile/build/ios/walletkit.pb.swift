// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: walletrpc/walletkit.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Walletrpc_AddressType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unknown // = 0
  case witnessPubkeyHash // = 1
  case nestedWitnessPubkeyHash // = 2
  case hybridNestedWitnessPubkeyHash // = 3
  case taprootPubkey // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .witnessPubkeyHash
    case 2: self = .nestedWitnessPubkeyHash
    case 3: self = .hybridNestedWitnessPubkeyHash
    case 4: self = .taprootPubkey
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .witnessPubkeyHash: return 1
    case .nestedWitnessPubkeyHash: return 2
    case .hybridNestedWitnessPubkeyHash: return 3
    case .taprootPubkey: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Walletrpc_AddressType] = [
    .unknown,
    .witnessPubkeyHash,
    .nestedWitnessPubkeyHash,
    .hybridNestedWitnessPubkeyHash,
    .taprootPubkey,
  ]

}

enum Walletrpc_WitnessType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unknownWitness // = 0

  ///
  ///A witness that allows us to spend the output of a commitment transaction
  ///after a relative lock-time lockout.
  case commitmentTimeLock // = 1

  ///
  ///A witness that allows us to spend a settled no-delay output immediately on a
  ///counterparty's commitment transaction.
  case commitmentNoDelay // = 2

  ///
  ///A witness that allows us to sweep the settled output of a malicious
  ///counterparty's who broadcasts a revoked commitment transaction.
  case commitmentRevoke // = 3

  ///
  ///A witness that allows us to sweep an HTLC which we offered to the remote
  ///party in the case that they broadcast a revoked commitment state.
  case htlcOfferedRevoke // = 4

  ///
  ///A witness that allows us to sweep an HTLC output sent to us in the case that
  ///the remote party broadcasts a revoked commitment state.
  case htlcAcceptedRevoke // = 5

  ///
  ///A witness that allows us to sweep an HTLC output that we extended to a
  ///party, but was never fulfilled.  This HTLC output isn't directly on the
  ///commitment transaction, but is the result of a confirmed second-level HTLC
  ///transaction. As a result, we can only spend this after a CSV delay.
  case htlcOfferedTimeoutSecondLevel // = 6

  ///
  ///A witness that allows us to sweep an HTLC output that was offered to us, and
  ///for which we have a payment preimage. This HTLC output isn't directly on our
  ///commitment transaction, but is the result of confirmed second-level HTLC
  ///transaction. As a result, we can only spend this after a CSV delay.
  case htlcAcceptedSuccessSecondLevel // = 7

  ///
  ///A witness that allows us to sweep an HTLC that we offered to the remote
  ///party which lies in the commitment transaction of the remote party. We can
  ///spend this output after the absolute CLTV timeout of the HTLC as passed.
  case htlcOfferedRemoteTimeout // = 8

  ///
  ///A witness that allows us to sweep an HTLC that was offered to us by the
  ///remote party. We use this witness in the case that the remote party goes to
  ///chain, and we know the pre-image to the HTLC. We can sweep this without any
  ///additional timeout.
  case htlcAcceptedRemoteSuccess // = 9

  ///
  ///A witness that allows us to sweep an HTLC from the remote party's commitment
  ///transaction in the case that the broadcast a revoked commitment, but then
  ///also immediately attempt to go to the second level to claim the HTLC.
  case htlcSecondLevelRevoke // = 10

  ///
  ///A witness type that allows us to spend a regular p2wkh output that's sent to
  ///an output which is under complete control of the backing wallet.
  case witnessKeyHash // = 11

  ///
  ///A witness type that allows us to sweep an output that sends to a nested P2SH
  ///script that pays to a key solely under our control.
  case nestedWitnessKeyHash // = 12

  ///
  ///A witness type that allows us to spend our anchor on the commitment
  ///transaction.
  case commitmentAnchor // = 13

  ///
  ///A witness type that is similar to the COMMITMENT_NO_DELAY type,
  ///but it omits the tweak that randomizes the key we need to
  ///spend with a channel peer supplied set of randomness.
  case commitmentNoDelayTweakless // = 14

  ///
  ///A witness type that allows us to spend our output on the counterparty's
  ///commitment transaction after a confirmation.
  case commitmentToRemoteConfirmed // = 15

  ///
  ///A witness type that allows us to sweep an HTLC output that we extended
  ///to a party, but was never fulfilled. This _is_ the HTLC output directly
  ///on our commitment transaction, and the input to the second-level HTLC
  ///timeout transaction. It can only be spent after CLTV expiry, and
  ///commitment confirmation.
  case htlcOfferedTimeoutSecondLevelInputConfirmed // = 16

  ///
  ///A witness type that allows us to sweep an HTLC output that was offered
  ///to us, and for which we have a payment preimage. This _is_ the HTLC
  ///output directly on our commitment transaction, and the input to the
  ///second-level HTLC success transaction. It can only be spent after the
  ///commitment has confirmed.
  case htlcAcceptedSuccessSecondLevelInputConfirmed // = 17

  ///
  ///A witness type that allows us to spend our output on our local
  ///commitment transaction after a relative and absolute lock-time lockout as
  ///part of the script enforced lease commitment type.
  case leaseCommitmentTimeLock // = 18

  ///
  ///A witness type that allows us to spend our output on the counterparty's
  ///commitment transaction after a confirmation and absolute locktime as part
  ///of the script enforced lease commitment type.
  case leaseCommitmentToRemoteConfirmed // = 19

  ///
  ///A witness type that allows us to sweep an HTLC output that we extended
  ///to a party, but was never fulfilled. This HTLC output isn't directly on
  ///the commitment transaction, but is the result of a confirmed second-level
  ///HTLC transaction. As a result, we can only spend this after a CSV delay
  ///and CLTV locktime as part of the script enforced lease commitment type.
  case leaseHtlcOfferedTimeoutSecondLevel // = 20

  ///
  ///A witness type that allows us to sweep an HTLC output that was offered
  ///to us, and for which we have a payment preimage. This HTLC output isn't
  ///directly on our commitment transaction, but is the result of confirmed
  ///second-level HTLC transaction. As a result, we can only spend this after
  ///a CSV delay and CLTV locktime as part of the script enforced lease
  ///commitment type.
  case leaseHtlcAcceptedSuccessSecondLevel // = 21

  ///
  ///A witness type that allows us to spend a regular p2tr output that's sent
  ///to an output which is under complete control of the backing wallet.
  case taprootPubKeySpend // = 22

  ///
  ///A witness type that allows us to spend our settled local commitment after a
  ///CSV delay when we force close the channel.
  case taprootLocalCommitSpend // = 23

  ///
  ///A witness type that allows us to spend our settled local commitment after
  ///a CSV delay when the remote party has force closed the channel.
  case taprootRemoteCommitSpend // = 24

  ///
  ///A witness type that we'll use for spending our own anchor output.
  case taprootAnchorSweepSpend // = 25

  ///
  ///A witness that allows us to timeout an HTLC we offered to the remote party
  ///on our commitment transaction. We use this when we need to go on chain to
  ///time out an HTLC.
  case taprootHtlcOfferedTimeoutSecondLevel // = 26

  ///
  ///A witness type that allows us to sweep an HTLC we accepted on our commitment
  ///transaction after we go to the second level on chain.
  case taprootHtlcAcceptedSuccessSecondLevel // = 27

  ///
  ///A witness that allows us to sweep an HTLC on the revoked transaction of the
  ///remote party that goes to the second level.
  case taprootHtlcSecondLevelRevoke // = 28

  ///
  ///A witness that allows us to sweep an HTLC sent to us by the remote party
  ///in the event that they broadcast a revoked state.
  case taprootHtlcAcceptedRevoke // = 29

  ///
  ///A witness that allows us to sweep an HTLC we offered to the remote party if
  ///they broadcast a revoked commitment.
  case taprootHtlcOfferedRevoke // = 30

  ///
  ///A witness that allows us to sweep an HTLC we offered to the remote party
  ///that lies on the commitment transaction for the remote party. We can spend
  ///this output after the absolute CLTV timeout of the HTLC as passed.
  case taprootHtlcOfferedRemoteTimeout // = 31

  ///
  ///A witness type that allows us to sign the second level HTLC timeout
  ///transaction when spending from an HTLC residing on our local commitment
  ///transaction.
  ///This is used by the sweeper to re-sign inputs if it needs to aggregate
  ///several second level HTLCs.
  case taprootHtlcLocalOfferedTimeout // = 32

  ///
  ///A witness that allows us to sweep an HTLC that was offered to us by the
  ///remote party for a taproot channels. We use this witness in the case that
  ///the remote party goes to chain, and we know the pre-image to the HTLC. We
  ///can sweep this without any additional timeout.
  case taprootHtlcAcceptedRemoteSuccess // = 33

  ///
  ///A witness type that allows us to sweep the HTLC offered to us on our local
  ///commitment transaction. We'll use this when we need to go on chain to sweep
  ///the HTLC. In this case, this is the second level HTLC success transaction.
  case taprootHtlcAcceptedLocalSuccess // = 34

  ///
  ///A witness that allows us to sweep the settled output of a malicious
  ///counterparty's who broadcasts a revoked taproot commitment transaction.
  case taprootCommitmentRevoke // = 35
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownWitness
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownWitness
    case 1: self = .commitmentTimeLock
    case 2: self = .commitmentNoDelay
    case 3: self = .commitmentRevoke
    case 4: self = .htlcOfferedRevoke
    case 5: self = .htlcAcceptedRevoke
    case 6: self = .htlcOfferedTimeoutSecondLevel
    case 7: self = .htlcAcceptedSuccessSecondLevel
    case 8: self = .htlcOfferedRemoteTimeout
    case 9: self = .htlcAcceptedRemoteSuccess
    case 10: self = .htlcSecondLevelRevoke
    case 11: self = .witnessKeyHash
    case 12: self = .nestedWitnessKeyHash
    case 13: self = .commitmentAnchor
    case 14: self = .commitmentNoDelayTweakless
    case 15: self = .commitmentToRemoteConfirmed
    case 16: self = .htlcOfferedTimeoutSecondLevelInputConfirmed
    case 17: self = .htlcAcceptedSuccessSecondLevelInputConfirmed
    case 18: self = .leaseCommitmentTimeLock
    case 19: self = .leaseCommitmentToRemoteConfirmed
    case 20: self = .leaseHtlcOfferedTimeoutSecondLevel
    case 21: self = .leaseHtlcAcceptedSuccessSecondLevel
    case 22: self = .taprootPubKeySpend
    case 23: self = .taprootLocalCommitSpend
    case 24: self = .taprootRemoteCommitSpend
    case 25: self = .taprootAnchorSweepSpend
    case 26: self = .taprootHtlcOfferedTimeoutSecondLevel
    case 27: self = .taprootHtlcAcceptedSuccessSecondLevel
    case 28: self = .taprootHtlcSecondLevelRevoke
    case 29: self = .taprootHtlcAcceptedRevoke
    case 30: self = .taprootHtlcOfferedRevoke
    case 31: self = .taprootHtlcOfferedRemoteTimeout
    case 32: self = .taprootHtlcLocalOfferedTimeout
    case 33: self = .taprootHtlcAcceptedRemoteSuccess
    case 34: self = .taprootHtlcAcceptedLocalSuccess
    case 35: self = .taprootCommitmentRevoke
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownWitness: return 0
    case .commitmentTimeLock: return 1
    case .commitmentNoDelay: return 2
    case .commitmentRevoke: return 3
    case .htlcOfferedRevoke: return 4
    case .htlcAcceptedRevoke: return 5
    case .htlcOfferedTimeoutSecondLevel: return 6
    case .htlcAcceptedSuccessSecondLevel: return 7
    case .htlcOfferedRemoteTimeout: return 8
    case .htlcAcceptedRemoteSuccess: return 9
    case .htlcSecondLevelRevoke: return 10
    case .witnessKeyHash: return 11
    case .nestedWitnessKeyHash: return 12
    case .commitmentAnchor: return 13
    case .commitmentNoDelayTweakless: return 14
    case .commitmentToRemoteConfirmed: return 15
    case .htlcOfferedTimeoutSecondLevelInputConfirmed: return 16
    case .htlcAcceptedSuccessSecondLevelInputConfirmed: return 17
    case .leaseCommitmentTimeLock: return 18
    case .leaseCommitmentToRemoteConfirmed: return 19
    case .leaseHtlcOfferedTimeoutSecondLevel: return 20
    case .leaseHtlcAcceptedSuccessSecondLevel: return 21
    case .taprootPubKeySpend: return 22
    case .taprootLocalCommitSpend: return 23
    case .taprootRemoteCommitSpend: return 24
    case .taprootAnchorSweepSpend: return 25
    case .taprootHtlcOfferedTimeoutSecondLevel: return 26
    case .taprootHtlcAcceptedSuccessSecondLevel: return 27
    case .taprootHtlcSecondLevelRevoke: return 28
    case .taprootHtlcAcceptedRevoke: return 29
    case .taprootHtlcOfferedRevoke: return 30
    case .taprootHtlcOfferedRemoteTimeout: return 31
    case .taprootHtlcLocalOfferedTimeout: return 32
    case .taprootHtlcAcceptedRemoteSuccess: return 33
    case .taprootHtlcAcceptedLocalSuccess: return 34
    case .taprootCommitmentRevoke: return 35
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Walletrpc_WitnessType] = [
    .unknownWitness,
    .commitmentTimeLock,
    .commitmentNoDelay,
    .commitmentRevoke,
    .htlcOfferedRevoke,
    .htlcAcceptedRevoke,
    .htlcOfferedTimeoutSecondLevel,
    .htlcAcceptedSuccessSecondLevel,
    .htlcOfferedRemoteTimeout,
    .htlcAcceptedRemoteSuccess,
    .htlcSecondLevelRevoke,
    .witnessKeyHash,
    .nestedWitnessKeyHash,
    .commitmentAnchor,
    .commitmentNoDelayTweakless,
    .commitmentToRemoteConfirmed,
    .htlcOfferedTimeoutSecondLevelInputConfirmed,
    .htlcAcceptedSuccessSecondLevelInputConfirmed,
    .leaseCommitmentTimeLock,
    .leaseCommitmentToRemoteConfirmed,
    .leaseHtlcOfferedTimeoutSecondLevel,
    .leaseHtlcAcceptedSuccessSecondLevel,
    .taprootPubKeySpend,
    .taprootLocalCommitSpend,
    .taprootRemoteCommitSpend,
    .taprootAnchorSweepSpend,
    .taprootHtlcOfferedTimeoutSecondLevel,
    .taprootHtlcAcceptedSuccessSecondLevel,
    .taprootHtlcSecondLevelRevoke,
    .taprootHtlcAcceptedRevoke,
    .taprootHtlcOfferedRevoke,
    .taprootHtlcOfferedRemoteTimeout,
    .taprootHtlcLocalOfferedTimeout,
    .taprootHtlcAcceptedRemoteSuccess,
    .taprootHtlcAcceptedLocalSuccess,
    .taprootCommitmentRevoke,
  ]

}

/// The possible change address types for default accounts and single imported
/// public keys. By default, P2WPKH will be used. We don't provide the
/// possibility to choose P2PKH as it is a legacy key scope, nor NP2WPKH as
/// no key scope permits to do so. For custom accounts, no change type should
/// be provided as the coin selection key scope will always be used to generate
/// the change address.
enum Walletrpc_ChangeAddressType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int

  /// CHANGE_ADDRESS_TYPE_UNSPECIFIED indicates that no change address type is
  /// provided. We will then use P2WPKH address type for change (BIP0084 key
  /// scope).
  case unspecified // = 0

  /// CHANGE_ADDRESS_TYPE_P2TR indicates to use P2TR address for change output
  /// (BIP0086 key scope).
  case p2Tr // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .p2Tr
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .p2Tr: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Walletrpc_ChangeAddressType] = [
    .unspecified,
    .p2Tr,
  ]

}

struct Walletrpc_ListUnspentRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The minimum number of confirmations to be included.
  var minConfs: Int32 = 0

  /// The maximum number of confirmations to be included.
  var maxConfs: Int32 = 0

  /// An optional filter to only include outputs belonging to an account.
  var account: String = String()

  ///
  ///When min_confs and max_confs are zero, setting false implicitly
  ///overrides max_confs to be MaxInt32, otherwise max_confs remains
  ///zero. An error is returned if the value is true and both min_confs
  ///and max_confs are non-zero. (default: false)
  var unconfirmedOnly: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_ListUnspentResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of utxos satisfying the specified number of confirmations.
  var utxos: [Lnrpc_Utxo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_LeaseOutputRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///An ID of 32 random bytes that must be unique for each distinct application
  ///using this RPC which will be used to bound the output lease to.
  var id: Data = Data()

  /// The identifying outpoint of the output being leased.
  var outpoint: Lnrpc_OutPoint {
    get {return _outpoint ?? Lnrpc_OutPoint()}
    set {_outpoint = newValue}
  }
  /// Returns true if `outpoint` has been explicitly set.
  var hasOutpoint: Bool {return self._outpoint != nil}
  /// Clears the value of `outpoint`. Subsequent reads from it will return its default value.
  mutating func clearOutpoint() {self._outpoint = nil}

  /// The time in seconds before the lock expires. If set to zero, the default
  /// lock duration is used.
  var expirationSeconds: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _outpoint: Lnrpc_OutPoint? = nil
}

struct Walletrpc_LeaseOutputResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The absolute expiration of the output lease represented as a unix timestamp.
  var expiration: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_ReleaseOutputRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique ID that was used to lock the output.
  var id: Data = Data()

  /// The identifying outpoint of the output being released.
  var outpoint: Lnrpc_OutPoint {
    get {return _outpoint ?? Lnrpc_OutPoint()}
    set {_outpoint = newValue}
  }
  /// Returns true if `outpoint` has been explicitly set.
  var hasOutpoint: Bool {return self._outpoint != nil}
  /// Clears the value of `outpoint`. Subsequent reads from it will return its default value.
  mutating func clearOutpoint() {self._outpoint = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _outpoint: Lnrpc_OutPoint? = nil
}

struct Walletrpc_ReleaseOutputResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_KeyReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///Is the key finger print of the root pubkey that this request is targeting.
  ///This allows the WalletKit to possibly serve out keys for multiple HD chains
  ///via public derivation.
  var keyFingerPrint: Int32 = 0

  ///
  ///The target key family to derive a key from. In other contexts, this is
  ///known as the "account".
  var keyFamily: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_AddrRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The name of the account to retrieve the next address of. If empty, the
  ///default wallet account is used.
  var account: String = String()

  ///
  ///The type of address to derive.
  var type: Walletrpc_AddressType = .unknown

  ///
  ///Whether a change address should be derived.
  var change: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_AddrResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The address encoded using a bech32 format.
  var addr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_Account: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name used to identify the account.
  var name: String = String()

  /// The type of addresses the account supports.
  var addressType: Walletrpc_AddressType = .unknown

  ///
  ///The public key backing the account that all keys are derived from
  ///represented as an extended key. This will always be empty for the default
  ///imported account in which single public keys are imported into.
  var extendedPublicKey: String = String()

  ///
  ///The fingerprint of the root key from which the account public key was
  ///derived from. This will always be zero for the default imported account in
  ///which single public keys are imported into. The bytes are in big-endian
  ///order.
  var masterKeyFingerprint: Data = Data()

  ///
  ///The derivation path corresponding to the account public key. This will
  ///always be empty for the default imported account in which single public keys
  ///are imported into.
  var derivationPath: String = String()

  ///
  ///The number of keys derived from the external branch of the account public
  ///key. This will always be zero for the default imported account in which
  ///single public keys are imported into.
  var externalKeyCount: UInt32 = 0

  ///
  ///The number of keys derived from the internal branch of the account public
  ///key. This will always be zero for the default imported account in which
  ///single public keys are imported into.
  var internalKeyCount: UInt32 = 0

  /// Whether the wallet stores private keys for the account.
  var watchOnly: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_AddressProperty: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The address encoded using the appropriate format depending on the
  ///address type (base58, bech32, bech32m).
  ///
  ///Note that lnd's internal/custom keys for channels and other
  ///functionality are derived from the same scope. Since they
  ///aren't really used as addresses and will never have an
  ///on-chain balance, we'll show the public key instead (only if
  ///the show_custom_accounts flag is provided).
  var address: String = String()

  /// Denotes if the address is a change address.
  var isInternal: Bool = false

  /// The balance of the address.
  var balance: Int64 = 0

  /// The full derivation path of the address. This will be empty for imported
  /// addresses.
  var derivationPath: String = String()

  /// The public key of the address. This will be empty for imported addresses.
  var publicKey: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_AccountWithAddresses: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name used to identify the account.
  var name: String = String()

  /// The type of addresses the account supports.
  var addressType: Walletrpc_AddressType = .unknown

  ///
  ///The derivation path corresponding to the account public key. This will
  ///always be empty for the default imported account in which single public keys
  ///are imported into.
  var derivationPath: String = String()

  ///
  ///List of address, its type internal/external & balance.
  ///Note that the order of addresses will be random and not according to the
  ///derivation index, since that information is not stored by the underlying
  ///wallet.
  var addresses: [Walletrpc_AddressProperty] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_ListAccountsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An optional filter to only return accounts matching this name.
  var name: String = String()

  /// An optional filter to only return accounts matching this address type.
  var addressType: Walletrpc_AddressType = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_ListAccountsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accounts: [Walletrpc_Account] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_RequiredReserveRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of additional channels the user would like to open.
  var additionalPublicChannels: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_RequiredReserveResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The amount of reserve required.
  var requiredReserve: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_ListAddressesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An optional filter to only return addresses matching this account.
  var accountName: String = String()

  /// An optional flag to return LND's custom accounts (Purpose=1017)
  /// public key along with other addresses.
  var showCustomAccounts: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_ListAddressesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of all the accounts and their addresses.
  var accountWithAddresses: [Walletrpc_AccountWithAddresses] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_GetTransactionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The txid of the transaction.
  var txid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_SignMessageWithAddrRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The message to be signed. When using REST, this field must be encoded as
  /// base64.
  var msg: Data = Data()

  /// The address which will be used to look up the private key and sign the
  /// corresponding message.
  var addr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_SignMessageWithAddrResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The compact ECDSA signature for the given message encoded in base64.
  var signature: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_VerifyMessageWithAddrRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The message to be signed. When using REST, this field must be encoded as
  /// base64.
  var msg: Data = Data()

  /// The compact ECDSA signature to be verified over the given message
  /// ecoded in base64.
  var signature: String = String()

  /// The address which will be used to look up the public key and verify the
  /// the signature.
  var addr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_VerifyMessageWithAddrResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether the signature was valid over the given message.
  var valid: Bool = false

  /// The pubkey recovered from the signature.
  var pubkey: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_ImportAccountRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A name to identify the account with.
  var name: String = String()

  ///
  ///A public key that corresponds to a wallet account represented as an extended
  ///key. It must conform to a derivation path of the form
  ///m/purpose'/coin_type'/account'.
  var extendedPublicKey: String = String()

  ///
  ///The fingerprint of the root key (also known as the key with derivation path
  ///m/) from which the account public key was derived from. This may be required
  ///by some hardware wallets for proper identification and signing. The bytes
  ///must be in big-endian order.
  var masterKeyFingerprint: Data = Data()

  ///
  ///An address type is only required when the extended account public key has a
  ///legacy version (xpub, tpub, etc.), such that the wallet cannot detect what
  ///address scheme it belongs to.
  var addressType: Walletrpc_AddressType = .unknown

  ///
  ///Whether a dry run should be attempted when importing the account. This
  ///serves as a way to confirm whether the account is being imported correctly
  ///by returning the first N addresses for the external and internal branches of
  ///the account. If these addresses match as expected, then it should be safe to
  ///import the account as is.
  var dryRun: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_ImportAccountResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The details of the imported account.
  var account: Walletrpc_Account {
    get {return _account ?? Walletrpc_Account()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {self._account = nil}

  ///
  ///The first N addresses that belong to the external branch of the account.
  ///The external branch is typically used for external non-change addresses.
  ///These are only returned if a dry run was specified within the request.
  var dryRunExternalAddrs: [String] = []

  ///
  ///The first N addresses that belong to the internal branch of the account.
  ///The internal branch is typically used for change addresses. These are only
  ///returned if a dry run was specified within the request.
  var dryRunInternalAddrs: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _account: Walletrpc_Account? = nil
}

struct Walletrpc_ImportPublicKeyRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A compressed public key represented as raw bytes.
  var publicKey: Data = Data()

  /// The type of address that will be generated from the public key.
  var addressType: Walletrpc_AddressType = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_ImportPublicKeyResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_ImportTapscriptRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The internal public key, serialized as 32-byte x-only public key.
  var internalPublicKey: Data = Data()

  var script: Walletrpc_ImportTapscriptRequest.OneOf_Script? = nil

  ///
  ///The full script tree with all individual leaves is known and the root
  ///hash can be constructed from the full tree directly.
  var fullTree: Walletrpc_TapscriptFullTree {
    get {
      if case .fullTree(let v)? = script {return v}
      return Walletrpc_TapscriptFullTree()
    }
    set {script = .fullTree(newValue)}
  }

  ///
  ///Only a single script leaf is known. To construct the root hash, the full
  ///inclusion proof must also be provided.
  var partialReveal: Walletrpc_TapscriptPartialReveal {
    get {
      if case .partialReveal(let v)? = script {return v}
      return Walletrpc_TapscriptPartialReveal()
    }
    set {script = .partialReveal(newValue)}
  }

  ///
  ///Only the root hash of the Taproot script tree (or other form of Taproot
  ///commitment) is known.
  var rootHashOnly: Data {
    get {
      if case .rootHashOnly(let v)? = script {return v}
      return Data()
    }
    set {script = .rootHashOnly(newValue)}
  }

  ///
  ///Only the final, tweaked Taproot key is known and no additional
  ///information about the internal key or type of tweak that was used to
  ///derive it. When this is set, the wallet treats the key in
  ///internal_public_key as the Taproot key directly. This can be useful for
  ///tracking arbitrary Taproot outputs without the goal of ever being able
  ///to spend from them through the internal wallet.
  var fullKeyOnly: Bool {
    get {
      if case .fullKeyOnly(let v)? = script {return v}
      return false
    }
    set {script = .fullKeyOnly(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Script: Equatable, @unchecked Sendable {
    ///
    ///The full script tree with all individual leaves is known and the root
    ///hash can be constructed from the full tree directly.
    case fullTree(Walletrpc_TapscriptFullTree)
    ///
    ///Only a single script leaf is known. To construct the root hash, the full
    ///inclusion proof must also be provided.
    case partialReveal(Walletrpc_TapscriptPartialReveal)
    ///
    ///Only the root hash of the Taproot script tree (or other form of Taproot
    ///commitment) is known.
    case rootHashOnly(Data)
    ///
    ///Only the final, tweaked Taproot key is known and no additional
    ///information about the internal key or type of tweak that was used to
    ///derive it. When this is set, the wallet treats the key in
    ///internal_public_key as the Taproot key directly. This can be useful for
    ///tracking arbitrary Taproot outputs without the goal of ever being able
    ///to spend from them through the internal wallet.
    case fullKeyOnly(Bool)

  }

  init() {}
}

struct Walletrpc_TapscriptFullTree: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The complete, ordered list of all tap leaves of the tree.
  var allLeaves: [Walletrpc_TapLeaf] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_TapLeaf: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The leaf version. Should be 0xc0 (192) in case of a SegWit v1 script.
  var leafVersion: UInt32 = 0

  /// The script of the tap leaf.
  var script: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_TapscriptPartialReveal: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The tap leaf that is known and will be revealed.
  var revealedLeaf: Walletrpc_TapLeaf {
    get {return _revealedLeaf ?? Walletrpc_TapLeaf()}
    set {_revealedLeaf = newValue}
  }
  /// Returns true if `revealedLeaf` has been explicitly set.
  var hasRevealedLeaf: Bool {return self._revealedLeaf != nil}
  /// Clears the value of `revealedLeaf`. Subsequent reads from it will return its default value.
  mutating func clearRevealedLeaf() {self._revealedLeaf = nil}

  /// The BIP-0341 serialized inclusion proof that is required to prove that
  /// the revealed leaf is part of the tree. This contains 0..n blocks of 32
  /// bytes. If the tree only contained a single leaf (which is the revealed
  /// leaf), this can be empty.
  var fullInclusionProof: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _revealedLeaf: Walletrpc_TapLeaf? = nil
}

struct Walletrpc_ImportTapscriptResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The resulting pay-to-Taproot address that represents the imported internal
  ///key with the script committed to it.
  var p2TrAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_Transaction: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The raw serialized transaction. Despite the field name, this does need to be
  ///specified in raw bytes (or base64 encoded when using REST) and not in hex.
  ///To not break existing software, the field can't simply be renamed.
  var txHex: Data = Data()

  ///
  ///An optional label to save with the transaction. Limited to 500 characters.
  var label: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_PublishResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///If blank, then no error occurred and the transaction was successfully
  ///published. If not the empty string, then a string representation of the
  ///broadcast error.
  ///
  ///TODO(roasbeef): map to a proper enum type
  var publishError: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_RemoveTransactionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The status of the remove transaction operation.
  var status: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_SendOutputsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The number of satoshis per kilo weight that should be used when crafting
  ///this transaction.
  var satPerKw: Int64 = 0

  ///
  ///A slice of the outputs that should be created in the transaction produced.
  var outputs: [Signrpc_TxOut] = []

  /// An optional label for the transaction, limited to 500 characters.
  var label: String = String()

  /// The minimum number of confirmations each one of your outputs used for
  /// the transaction must satisfy.
  var minConfs: Int32 = 0

  /// Whether unconfirmed outputs should be used as inputs for the transaction.
  var spendUnconfirmed: Bool = false

  /// The strategy to use for selecting coins during sending the outputs.
  var coinSelectionStrategy: Lnrpc_CoinSelectionStrategy = .strategyUseGlobalConfig

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_SendOutputsResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The serialized transaction sent out on the network.
  var rawTx: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_EstimateFeeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The number of confirmations to shoot for when estimating the fee.
  var confTarget: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_EstimateFeeResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The amount of satoshis per kw that should be used in order to reach the
  ///confirmation target in the request.
  var satPerKw: Int64 = 0

  /// The current minimum relay fee based on our chain backend in sat/kw.
  var minRelayFeeSatPerKw: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_PendingSweep: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The outpoint of the output we're attempting to sweep.
  var outpoint: Lnrpc_OutPoint {
    get {return _outpoint ?? Lnrpc_OutPoint()}
    set {_outpoint = newValue}
  }
  /// Returns true if `outpoint` has been explicitly set.
  var hasOutpoint: Bool {return self._outpoint != nil}
  /// Clears the value of `outpoint`. Subsequent reads from it will return its default value.
  mutating func clearOutpoint() {self._outpoint = nil}

  /// The witness type of the output we're attempting to sweep.
  var witnessType: Walletrpc_WitnessType = .unknownWitness

  /// The value of the output we're attempting to sweep.
  var amountSat: UInt32 = 0

  ///
  ///Deprecated, use sat_per_vbyte.
  ///The fee rate we'll use to sweep the output, expressed in sat/vbyte. The fee
  ///rate is only determined once a sweeping transaction for the output is
  ///created, so it's possible for this to be 0 before this.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  var satPerByte: UInt32 = 0

  /// The number of broadcast attempts we've made to sweep the output.
  var broadcastAttempts: UInt32 = 0

  ///
  ///Deprecated.
  ///The next height of the chain at which we'll attempt to broadcast the
  ///sweep transaction of the output.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  var nextBroadcastHeight: UInt32 = 0

  ///
  ///Deprecated, use immediate.
  ///Whether this input must be force-swept. This means that it is swept
  ///immediately.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  var force: Bool = false

  ///
  ///Deprecated, use deadline.
  ///The requested confirmation target for this output, which is the deadline
  ///used by the sweeper.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  var requestedConfTarget: UInt32 = 0

  /// Deprecated, use requested_sat_per_vbyte.
  /// The requested fee rate, expressed in sat/vbyte, for this output.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  var requestedSatPerByte: UInt32 = 0

  ///
  ///The current fee rate we'll use to sweep the output, expressed in sat/vbyte.
  ///The fee rate is only determined once a sweeping transaction for the output
  ///is created, so it's possible for this to be 0 before this.
  var satPerVbyte: UInt64 = 0

  /// The requested starting fee rate, expressed in sat/vbyte, for this
  /// output. When not requested, this field will be 0.
  var requestedSatPerVbyte: UInt64 = 0

  ///
  ///Whether this input will be swept immediately.
  var immediate: Bool = false

  ///
  ///The budget for this sweep, expressed in satoshis. This is the maximum amount
  ///that can be spent as fees to sweep this output.
  var budget: UInt64 = 0

  ///
  ///The deadline height used for this output when perform fee bumping.
  var deadlineHeight: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _outpoint: Lnrpc_OutPoint? = nil
}

struct Walletrpc_PendingSweepsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_PendingSweepsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The set of outputs currently being swept by lnd's central batching engine.
  var pendingSweeps: [Walletrpc_PendingSweep] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_BumpFeeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The input we're attempting to bump the fee of.
  var outpoint: Lnrpc_OutPoint {
    get {return _outpoint ?? Lnrpc_OutPoint()}
    set {_outpoint = newValue}
  }
  /// Returns true if `outpoint` has been explicitly set.
  var hasOutpoint: Bool {return self._outpoint != nil}
  /// Clears the value of `outpoint`. Subsequent reads from it will return its default value.
  mutating func clearOutpoint() {self._outpoint = nil}

  /// Optional. The deadline in number of blocks that the input should be spent
  /// within. When not set, for new inputs, the default value (1008) is used;
  /// for existing inputs, their current values will be retained.
  var targetConf: UInt32 = 0

  ///
  ///Deprecated, use sat_per_vbyte.
  ///The fee rate, expressed in sat/vbyte, that should be used to spend the input
  ///with.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  var satPerByte: UInt32 = 0

  ///
  ///Deprecated, use immediate.
  ///Whether this input must be force-swept. This means that it is swept
  ///immediately.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  var force: Bool = false

  ///
  ///Optional. The starting fee rate, expressed in sat/vbyte, that will be used
  ///to spend the input with initially. This value will be used by the sweeper's
  ///fee function as its starting fee rate. When not set, the sweeper will use
  ///the estimated fee rate using the `target_conf` as the starting fee rate.
  var satPerVbyte: UInt64 = 0

  ///
  ///Optional. Whether this input will be swept immediately. When set to true,
  ///the sweeper will sweep this input without waiting for the next batch.
  var immediate: Bool = false

  ///
  ///Optional. The max amount in sats that can be used as the fees. Setting this
  ///value greater than the input's value may result in CPFP - one or more wallet
  ///utxos will be used to pay the fees specified by the budget. If not set, for
  ///new inputs, by default 50% of the input's value will be treated as the
  ///budget for fee bumping; for existing inputs, their current budgets will be
  ///retained.
  var budget: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _outpoint: Lnrpc_OutPoint? = nil
}

struct Walletrpc_BumpFeeResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The status of the bump fee operation.
  var status: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_ListSweepsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///Retrieve the full sweep transaction details. If false, only the sweep txids
  ///will be returned. Note that some sweeps that LND publishes will have been
  ///replaced-by-fee, so will not be included in this output.
  var verbose: Bool = false

  ///
  ///The start height to use when fetching sweeps. If not specified (0), the
  ///result will start from the earliest sweep. If set to -1 the result will
  ///only include unconfirmed sweeps (at the time of the call).
  var startHeight: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_ListSweepsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sweeps: Walletrpc_ListSweepsResponse.OneOf_Sweeps? = nil

  var transactionDetails: Lnrpc_TransactionDetails {
    get {
      if case .transactionDetails(let v)? = sweeps {return v}
      return Lnrpc_TransactionDetails()
    }
    set {sweeps = .transactionDetails(newValue)}
  }

  var transactionIds: Walletrpc_ListSweepsResponse.TransactionIDs {
    get {
      if case .transactionIds(let v)? = sweeps {return v}
      return Walletrpc_ListSweepsResponse.TransactionIDs()
    }
    set {sweeps = .transactionIds(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Sweeps: Equatable, Sendable {
    case transactionDetails(Lnrpc_TransactionDetails)
    case transactionIds(Walletrpc_ListSweepsResponse.TransactionIDs)

  }

  struct TransactionIDs: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    ///Reversed, hex-encoded string representing the transaction ids of the
    ///sweeps that our node has broadcast. Note that these transactions may
    ///not have confirmed yet, we record sweeps on broadcast, not confirmation.
    var transactionIds: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Walletrpc_LabelTransactionRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The txid of the transaction to label. Note: When using gRPC, the bytes
  /// must be in little-endian (reverse) order.
  var txid: Data = Data()

  /// The label to add to the transaction, limited to 500 characters.
  var label: String = String()

  /// Whether to overwrite the existing label, if it is present.
  var overwrite: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_LabelTransactionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_FundPsbtRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var template: Walletrpc_FundPsbtRequest.OneOf_Template? = nil

  ///
  ///Use an existing PSBT packet as the template for the funded PSBT.
  ///
  ///The packet must contain at least one non-dust output. If one or more
  ///inputs are specified, no coin selection is performed. In that case every
  ///input must be an UTXO known to the wallet that has not been locked
  ///before. The sum of all inputs must be sufficiently greater than the sum
  ///of all outputs to pay a miner fee with the specified fee rate. A change
  ///output is added to the PSBT if necessary.
  var psbt: Data {
    get {
      if case .psbt(let v)? = template {return v}
      return Data()
    }
    set {template = .psbt(newValue)}
  }

  ///
  ///Use the outputs and optional inputs from this raw template.
  var raw: Walletrpc_TxTemplate {
    get {
      if case .raw(let v)? = template {return v}
      return Walletrpc_TxTemplate()
    }
    set {template = .raw(newValue)}
  }

  ///
  ///Use an existing PSBT packet as the template for the funded PSBT.
  ///
  ///The difference to the pure PSBT template above is that coin selection is
  ///performed even if inputs are specified. The output amounts are summed up
  ///and used as the target amount for coin selection. A change output must
  ///either already exist in the PSBT and be marked as such, otherwise a new
  ///change output of the specified output type will be added. Any inputs
  ///already specified in the PSBT must already be locked (if they belong to
  ///this node), only newly added inputs will be locked by this RPC.
  ///
  ///In case the sum of the already provided inputs exceeds the required
  ///output amount, no new coins are selected. Instead only the fee and
  ///change amount calculation is performed (e.g. a change output is added if
  ///requested or the change is added to the specified existing change
  ///output, given there is any non-dust change). This can be identified by
  ///the returned locked UTXOs being empty.
  var coinSelect: Walletrpc_PsbtCoinSelect {
    get {
      if case .coinSelect(let v)? = template {return v}
      return Walletrpc_PsbtCoinSelect()
    }
    set {template = .coinSelect(newValue)}
  }

  var fees: Walletrpc_FundPsbtRequest.OneOf_Fees? = nil

  ///
  ///The target number of blocks that the transaction should be confirmed in.
  var targetConf: UInt32 {
    get {
      if case .targetConf(let v)? = fees {return v}
      return 0
    }
    set {fees = .targetConf(newValue)}
  }

  ///
  ///The fee rate, expressed in sat/vbyte, that should be used to spend the
  ///input with.
  var satPerVbyte: UInt64 {
    get {
      if case .satPerVbyte(let v)? = fees {return v}
      return 0
    }
    set {fees = .satPerVbyte(newValue)}
  }

  ///
  ///The name of the account to fund the PSBT with. If empty, the default wallet
  ///account is used.
  var account: String = String()

  /// The minimum number of confirmations each one of your outputs used for
  /// the transaction must satisfy.
  var minConfs: Int32 = 0

  /// Whether unconfirmed outputs should be used as inputs for the transaction.
  var spendUnconfirmed: Bool = false

  /// The address type for the change. If empty, P2WPKH addresses will be used
  /// for default accounts and single imported public keys. For custom
  /// accounts, no change type should be provided as the coin selection key
  /// scope will always be used to generate the change address.
  var changeType: Walletrpc_ChangeAddressType = .unspecified

  /// The strategy to use for selecting coins during funding the PSBT.
  var coinSelectionStrategy: Lnrpc_CoinSelectionStrategy = .strategyUseGlobalConfig

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Template: Equatable, @unchecked Sendable {
    ///
    ///Use an existing PSBT packet as the template for the funded PSBT.
    ///
    ///The packet must contain at least one non-dust output. If one or more
    ///inputs are specified, no coin selection is performed. In that case every
    ///input must be an UTXO known to the wallet that has not been locked
    ///before. The sum of all inputs must be sufficiently greater than the sum
    ///of all outputs to pay a miner fee with the specified fee rate. A change
    ///output is added to the PSBT if necessary.
    case psbt(Data)
    ///
    ///Use the outputs and optional inputs from this raw template.
    case raw(Walletrpc_TxTemplate)
    ///
    ///Use an existing PSBT packet as the template for the funded PSBT.
    ///
    ///The difference to the pure PSBT template above is that coin selection is
    ///performed even if inputs are specified. The output amounts are summed up
    ///and used as the target amount for coin selection. A change output must
    ///either already exist in the PSBT and be marked as such, otherwise a new
    ///change output of the specified output type will be added. Any inputs
    ///already specified in the PSBT must already be locked (if they belong to
    ///this node), only newly added inputs will be locked by this RPC.
    ///
    ///In case the sum of the already provided inputs exceeds the required
    ///output amount, no new coins are selected. Instead only the fee and
    ///change amount calculation is performed (e.g. a change output is added if
    ///requested or the change is added to the specified existing change
    ///output, given there is any non-dust change). This can be identified by
    ///the returned locked UTXOs being empty.
    case coinSelect(Walletrpc_PsbtCoinSelect)

  }

  enum OneOf_Fees: Equatable, Sendable {
    ///
    ///The target number of blocks that the transaction should be confirmed in.
    case targetConf(UInt32)
    ///
    ///The fee rate, expressed in sat/vbyte, that should be used to spend the
    ///input with.
    case satPerVbyte(UInt64)

  }

  init() {}
}

struct Walletrpc_FundPsbtResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The funded but not yet signed PSBT packet.
  var fundedPsbt: Data = Data()

  ///
  ///The index of the added change output or -1 if no change was left over.
  var changeOutputIndex: Int32 = 0

  ///
  ///The list of lock leases that were acquired for the inputs in the funded PSBT
  ///packet. Only inputs added to the PSBT by this RPC are locked, inputs that
  ///were already present in the PSBT are not locked.
  var lockedUtxos: [Walletrpc_UtxoLease] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_TxTemplate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///An optional list of inputs to use. Every input must be an UTXO known to the
  ///wallet that has not been locked before. The sum of all inputs must be
  ///sufficiently greater than the sum of all outputs to pay a miner fee with the
  ///fee rate specified in the parent message.
  ///
  ///If no inputs are specified, coin selection will be performed instead and
  ///inputs of sufficient value will be added to the resulting PSBT.
  var inputs: [Lnrpc_OutPoint] = []

  ///
  ///A map of all addresses and the amounts to send to in the funded PSBT.
  var outputs: Dictionary<String,UInt64> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_PsbtCoinSelect: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The template to use for the funded PSBT. The template must contain at least
  ///one non-dust output. The amount to be funded is calculated by summing up the
  ///amounts of all outputs in the template, subtracting all the input values of
  ///the already specified inputs. The change value is added to the output that
  ///is marked as such (or a new change output is added if none is marked). For
  ///the input amount calculation to be correct, the template must have the
  ///WitnessUtxo field set for all inputs. Any inputs already specified in the
  ///PSBT must already be locked (if they belong to this node), only newly added
  ///inputs will be locked by this RPC.
  var psbt: Data = Data()

  var changeOutput: Walletrpc_PsbtCoinSelect.OneOf_ChangeOutput? = nil

  ///
  ///Use the existing output within the template PSBT with the specified
  ///index as the change output. Any leftover change will be added to the
  ///already specified amount of that output. To add a new change output to
  ///the PSBT, set the "add" field below instead. The type of change output
  ///added is defined by change_type in the parent message.
  var existingOutputIndex: Int32 {
    get {
      if case .existingOutputIndex(let v)? = changeOutput {return v}
      return 0
    }
    set {changeOutput = .existingOutputIndex(newValue)}
  }

  ///
  ///Add a new change output to the PSBT using the change_type specified in
  ///the parent message.
  var add: Bool {
    get {
      if case .add(let v)? = changeOutput {return v}
      return false
    }
    set {changeOutput = .add(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ChangeOutput: Equatable, Sendable {
    ///
    ///Use the existing output within the template PSBT with the specified
    ///index as the change output. Any leftover change will be added to the
    ///already specified amount of that output. To add a new change output to
    ///the PSBT, set the "add" field below instead. The type of change output
    ///added is defined by change_type in the parent message.
    case existingOutputIndex(Int32)
    ///
    ///Add a new change output to the PSBT using the change_type specified in
    ///the parent message.
    case add(Bool)

  }

  init() {}
}

struct Walletrpc_UtxoLease: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///A 32 byte random ID that identifies the lease.
  var id: Data = Data()

  /// The identifying outpoint of the output being leased.
  var outpoint: Lnrpc_OutPoint {
    get {return _outpoint ?? Lnrpc_OutPoint()}
    set {_outpoint = newValue}
  }
  /// Returns true if `outpoint` has been explicitly set.
  var hasOutpoint: Bool {return self._outpoint != nil}
  /// Clears the value of `outpoint`. Subsequent reads from it will return its default value.
  mutating func clearOutpoint() {self._outpoint = nil}

  ///
  ///The absolute expiration of the output lease represented as a unix timestamp.
  var expiration: UInt64 = 0

  ///
  ///The public key script of the leased output.
  var pkScript: Data = Data()

  ///
  ///The value of the leased output in satoshis.
  var value: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _outpoint: Lnrpc_OutPoint? = nil
}

struct Walletrpc_SignPsbtRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The PSBT that should be signed. The PSBT must contain all required inputs,
  ///outputs, UTXO data and custom fields required to identify the signing key.
  var fundedPsbt: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_SignPsbtResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The signed transaction in PSBT format.
  var signedPsbt: Data = Data()

  /// The indices of signed inputs.
  var signedInputs: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_FinalizePsbtRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///A PSBT that should be signed and finalized. The PSBT must contain all
  ///required inputs, outputs, UTXO data and partial signatures of all other
  ///signers.
  var fundedPsbt: Data = Data()

  ///
  ///The name of the account to finalize the PSBT with. If empty, the default
  ///wallet account is used.
  var account: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_FinalizePsbtResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The fully signed and finalized transaction in PSBT format.
  var signedPsbt: Data = Data()

  /// The fully signed and finalized transaction in the raw wire format.
  var rawFinalTx: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_ListLeasesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_ListLeasesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of currently leased utxos.
  var lockedUtxos: [Walletrpc_UtxoLease] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "walletrpc"

extension Walletrpc_AddressType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "WITNESS_PUBKEY_HASH"),
    2: .same(proto: "NESTED_WITNESS_PUBKEY_HASH"),
    3: .same(proto: "HYBRID_NESTED_WITNESS_PUBKEY_HASH"),
    4: .same(proto: "TAPROOT_PUBKEY"),
  ]
}

extension Walletrpc_WitnessType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_WITNESS"),
    1: .same(proto: "COMMITMENT_TIME_LOCK"),
    2: .same(proto: "COMMITMENT_NO_DELAY"),
    3: .same(proto: "COMMITMENT_REVOKE"),
    4: .same(proto: "HTLC_OFFERED_REVOKE"),
    5: .same(proto: "HTLC_ACCEPTED_REVOKE"),
    6: .same(proto: "HTLC_OFFERED_TIMEOUT_SECOND_LEVEL"),
    7: .same(proto: "HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL"),
    8: .same(proto: "HTLC_OFFERED_REMOTE_TIMEOUT"),
    9: .same(proto: "HTLC_ACCEPTED_REMOTE_SUCCESS"),
    10: .same(proto: "HTLC_SECOND_LEVEL_REVOKE"),
    11: .same(proto: "WITNESS_KEY_HASH"),
    12: .same(proto: "NESTED_WITNESS_KEY_HASH"),
    13: .same(proto: "COMMITMENT_ANCHOR"),
    14: .same(proto: "COMMITMENT_NO_DELAY_TWEAKLESS"),
    15: .same(proto: "COMMITMENT_TO_REMOTE_CONFIRMED"),
    16: .same(proto: "HTLC_OFFERED_TIMEOUT_SECOND_LEVEL_INPUT_CONFIRMED"),
    17: .same(proto: "HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL_INPUT_CONFIRMED"),
    18: .same(proto: "LEASE_COMMITMENT_TIME_LOCK"),
    19: .same(proto: "LEASE_COMMITMENT_TO_REMOTE_CONFIRMED"),
    20: .same(proto: "LEASE_HTLC_OFFERED_TIMEOUT_SECOND_LEVEL"),
    21: .same(proto: "LEASE_HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL"),
    22: .same(proto: "TAPROOT_PUB_KEY_SPEND"),
    23: .same(proto: "TAPROOT_LOCAL_COMMIT_SPEND"),
    24: .same(proto: "TAPROOT_REMOTE_COMMIT_SPEND"),
    25: .same(proto: "TAPROOT_ANCHOR_SWEEP_SPEND"),
    26: .same(proto: "TAPROOT_HTLC_OFFERED_TIMEOUT_SECOND_LEVEL"),
    27: .same(proto: "TAPROOT_HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL"),
    28: .same(proto: "TAPROOT_HTLC_SECOND_LEVEL_REVOKE"),
    29: .same(proto: "TAPROOT_HTLC_ACCEPTED_REVOKE"),
    30: .same(proto: "TAPROOT_HTLC_OFFERED_REVOKE"),
    31: .same(proto: "TAPROOT_HTLC_OFFERED_REMOTE_TIMEOUT"),
    32: .same(proto: "TAPROOT_HTLC_LOCAL_OFFERED_TIMEOUT"),
    33: .same(proto: "TAPROOT_HTLC_ACCEPTED_REMOTE_SUCCESS"),
    34: .same(proto: "TAPROOT_HTLC_ACCEPTED_LOCAL_SUCCESS"),
    35: .same(proto: "TAPROOT_COMMITMENT_REVOKE"),
  ]
}

extension Walletrpc_ChangeAddressType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHANGE_ADDRESS_TYPE_UNSPECIFIED"),
    1: .same(proto: "CHANGE_ADDRESS_TYPE_P2TR"),
  ]
}

extension Walletrpc_ListUnspentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListUnspentRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_confs"),
    2: .standard(proto: "max_confs"),
    3: .same(proto: "account"),
    4: .standard(proto: "unconfirmed_only"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.minConfs) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maxConfs) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.unconfirmedOnly) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minConfs != 0 {
      try visitor.visitSingularInt32Field(value: self.minConfs, fieldNumber: 1)
    }
    if self.maxConfs != 0 {
      try visitor.visitSingularInt32Field(value: self.maxConfs, fieldNumber: 2)
    }
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 3)
    }
    if self.unconfirmedOnly != false {
      try visitor.visitSingularBoolField(value: self.unconfirmedOnly, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ListUnspentRequest, rhs: Walletrpc_ListUnspentRequest) -> Bool {
    if lhs.minConfs != rhs.minConfs {return false}
    if lhs.maxConfs != rhs.maxConfs {return false}
    if lhs.account != rhs.account {return false}
    if lhs.unconfirmedOnly != rhs.unconfirmedOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ListUnspentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListUnspentResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "utxos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.utxos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.utxos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.utxos, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ListUnspentResponse, rhs: Walletrpc_ListUnspentResponse) -> Bool {
    if lhs.utxos != rhs.utxos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_LeaseOutputRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LeaseOutputRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "outpoint"),
    3: .standard(proto: "expiration_seconds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._outpoint) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.expirationSeconds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._outpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.expirationSeconds != 0 {
      try visitor.visitSingularUInt64Field(value: self.expirationSeconds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_LeaseOutputRequest, rhs: Walletrpc_LeaseOutputRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._outpoint != rhs._outpoint {return false}
    if lhs.expirationSeconds != rhs.expirationSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_LeaseOutputResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LeaseOutputResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "expiration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.expiration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.expiration != 0 {
      try visitor.visitSingularUInt64Field(value: self.expiration, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_LeaseOutputResponse, rhs: Walletrpc_LeaseOutputResponse) -> Bool {
    if lhs.expiration != rhs.expiration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ReleaseOutputRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReleaseOutputRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "outpoint"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._outpoint) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._outpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ReleaseOutputRequest, rhs: Walletrpc_ReleaseOutputRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._outpoint != rhs._outpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ReleaseOutputResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReleaseOutputResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ReleaseOutputResponse, rhs: Walletrpc_ReleaseOutputResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_KeyReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_finger_print"),
    2: .standard(proto: "key_family"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.keyFingerPrint) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.keyFamily) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.keyFingerPrint != 0 {
      try visitor.visitSingularInt32Field(value: self.keyFingerPrint, fieldNumber: 1)
    }
    if self.keyFamily != 0 {
      try visitor.visitSingularInt32Field(value: self.keyFamily, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_KeyReq, rhs: Walletrpc_KeyReq) -> Bool {
    if lhs.keyFingerPrint != rhs.keyFingerPrint {return false}
    if lhs.keyFamily != rhs.keyFamily {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_AddrRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddrRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "type"),
    3: .same(proto: "change"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.change) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if self.change != false {
      try visitor.visitSingularBoolField(value: self.change, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_AddrRequest, rhs: Walletrpc_AddrRequest) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.type != rhs.type {return false}
    if lhs.change != rhs.change {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_AddrResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddrResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.addr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addr.isEmpty {
      try visitor.visitSingularStringField(value: self.addr, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_AddrResponse, rhs: Walletrpc_AddrResponse) -> Bool {
    if lhs.addr != rhs.addr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_Account: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Account"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "address_type"),
    3: .standard(proto: "extended_public_key"),
    4: .standard(proto: "master_key_fingerprint"),
    5: .standard(proto: "derivation_path"),
    6: .standard(proto: "external_key_count"),
    7: .standard(proto: "internal_key_count"),
    8: .standard(proto: "watch_only"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.addressType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.extendedPublicKey) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.masterKeyFingerprint) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.derivationPath) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.externalKeyCount) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.internalKeyCount) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.watchOnly) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.addressType != .unknown {
      try visitor.visitSingularEnumField(value: self.addressType, fieldNumber: 2)
    }
    if !self.extendedPublicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.extendedPublicKey, fieldNumber: 3)
    }
    if !self.masterKeyFingerprint.isEmpty {
      try visitor.visitSingularBytesField(value: self.masterKeyFingerprint, fieldNumber: 4)
    }
    if !self.derivationPath.isEmpty {
      try visitor.visitSingularStringField(value: self.derivationPath, fieldNumber: 5)
    }
    if self.externalKeyCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.externalKeyCount, fieldNumber: 6)
    }
    if self.internalKeyCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.internalKeyCount, fieldNumber: 7)
    }
    if self.watchOnly != false {
      try visitor.visitSingularBoolField(value: self.watchOnly, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_Account, rhs: Walletrpc_Account) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.addressType != rhs.addressType {return false}
    if lhs.extendedPublicKey != rhs.extendedPublicKey {return false}
    if lhs.masterKeyFingerprint != rhs.masterKeyFingerprint {return false}
    if lhs.derivationPath != rhs.derivationPath {return false}
    if lhs.externalKeyCount != rhs.externalKeyCount {return false}
    if lhs.internalKeyCount != rhs.internalKeyCount {return false}
    if lhs.watchOnly != rhs.watchOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_AddressProperty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddressProperty"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "is_internal"),
    3: .same(proto: "balance"),
    4: .standard(proto: "derivation_path"),
    5: .standard(proto: "public_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isInternal) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.balance) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.derivationPath) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if self.isInternal != false {
      try visitor.visitSingularBoolField(value: self.isInternal, fieldNumber: 2)
    }
    if self.balance != 0 {
      try visitor.visitSingularInt64Field(value: self.balance, fieldNumber: 3)
    }
    if !self.derivationPath.isEmpty {
      try visitor.visitSingularStringField(value: self.derivationPath, fieldNumber: 4)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_AddressProperty, rhs: Walletrpc_AddressProperty) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.isInternal != rhs.isInternal {return false}
    if lhs.balance != rhs.balance {return false}
    if lhs.derivationPath != rhs.derivationPath {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_AccountWithAddresses: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountWithAddresses"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "address_type"),
    3: .standard(proto: "derivation_path"),
    4: .same(proto: "addresses"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.addressType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.derivationPath) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.addresses) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.addressType != .unknown {
      try visitor.visitSingularEnumField(value: self.addressType, fieldNumber: 2)
    }
    if !self.derivationPath.isEmpty {
      try visitor.visitSingularStringField(value: self.derivationPath, fieldNumber: 3)
    }
    if !self.addresses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.addresses, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_AccountWithAddresses, rhs: Walletrpc_AccountWithAddresses) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.addressType != rhs.addressType {return false}
    if lhs.derivationPath != rhs.derivationPath {return false}
    if lhs.addresses != rhs.addresses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ListAccountsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListAccountsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "address_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.addressType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.addressType != .unknown {
      try visitor.visitSingularEnumField(value: self.addressType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ListAccountsRequest, rhs: Walletrpc_ListAccountsRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.addressType != rhs.addressType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ListAccountsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListAccountsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accounts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.accounts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accounts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accounts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ListAccountsResponse, rhs: Walletrpc_ListAccountsResponse) -> Bool {
    if lhs.accounts != rhs.accounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_RequiredReserveRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequiredReserveRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "additional_public_channels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.additionalPublicChannels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.additionalPublicChannels != 0 {
      try visitor.visitSingularUInt32Field(value: self.additionalPublicChannels, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_RequiredReserveRequest, rhs: Walletrpc_RequiredReserveRequest) -> Bool {
    if lhs.additionalPublicChannels != rhs.additionalPublicChannels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_RequiredReserveResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequiredReserveResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "required_reserve"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.requiredReserve) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.requiredReserve != 0 {
      try visitor.visitSingularInt64Field(value: self.requiredReserve, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_RequiredReserveResponse, rhs: Walletrpc_RequiredReserveResponse) -> Bool {
    if lhs.requiredReserve != rhs.requiredReserve {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ListAddressesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListAddressesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_name"),
    2: .standard(proto: "show_custom_accounts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountName) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.showCustomAccounts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountName.isEmpty {
      try visitor.visitSingularStringField(value: self.accountName, fieldNumber: 1)
    }
    if self.showCustomAccounts != false {
      try visitor.visitSingularBoolField(value: self.showCustomAccounts, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ListAddressesRequest, rhs: Walletrpc_ListAddressesRequest) -> Bool {
    if lhs.accountName != rhs.accountName {return false}
    if lhs.showCustomAccounts != rhs.showCustomAccounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ListAddressesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListAddressesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_with_addresses"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.accountWithAddresses) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountWithAddresses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accountWithAddresses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ListAddressesResponse, rhs: Walletrpc_ListAddressesResponse) -> Bool {
    if lhs.accountWithAddresses != rhs.accountWithAddresses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_GetTransactionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTransactionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.txid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txid.isEmpty {
      try visitor.visitSingularStringField(value: self.txid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_GetTransactionRequest, rhs: Walletrpc_GetTransactionRequest) -> Bool {
    if lhs.txid != rhs.txid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_SignMessageWithAddrRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignMessageWithAddrRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "msg"),
    2: .same(proto: "addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.msg) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.addr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.msg.isEmpty {
      try visitor.visitSingularBytesField(value: self.msg, fieldNumber: 1)
    }
    if !self.addr.isEmpty {
      try visitor.visitSingularStringField(value: self.addr, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_SignMessageWithAddrRequest, rhs: Walletrpc_SignMessageWithAddrRequest) -> Bool {
    if lhs.msg != rhs.msg {return false}
    if lhs.addr != rhs.addr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_SignMessageWithAddrResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignMessageWithAddrResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.signature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signature.isEmpty {
      try visitor.visitSingularStringField(value: self.signature, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_SignMessageWithAddrResponse, rhs: Walletrpc_SignMessageWithAddrResponse) -> Bool {
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_VerifyMessageWithAddrRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerifyMessageWithAddrRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "msg"),
    2: .same(proto: "signature"),
    3: .same(proto: "addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.msg) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.signature) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.addr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.msg.isEmpty {
      try visitor.visitSingularBytesField(value: self.msg, fieldNumber: 1)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularStringField(value: self.signature, fieldNumber: 2)
    }
    if !self.addr.isEmpty {
      try visitor.visitSingularStringField(value: self.addr, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_VerifyMessageWithAddrRequest, rhs: Walletrpc_VerifyMessageWithAddrRequest) -> Bool {
    if lhs.msg != rhs.msg {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.addr != rhs.addr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_VerifyMessageWithAddrResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerifyMessageWithAddrResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "valid"),
    2: .same(proto: "pubkey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.valid) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.pubkey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.valid != false {
      try visitor.visitSingularBoolField(value: self.valid, fieldNumber: 1)
    }
    if !self.pubkey.isEmpty {
      try visitor.visitSingularBytesField(value: self.pubkey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_VerifyMessageWithAddrResponse, rhs: Walletrpc_VerifyMessageWithAddrResponse) -> Bool {
    if lhs.valid != rhs.valid {return false}
    if lhs.pubkey != rhs.pubkey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ImportAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImportAccountRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "extended_public_key"),
    3: .standard(proto: "master_key_fingerprint"),
    4: .standard(proto: "address_type"),
    5: .standard(proto: "dry_run"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.extendedPublicKey) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.masterKeyFingerprint) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.addressType) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.dryRun) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.extendedPublicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.extendedPublicKey, fieldNumber: 2)
    }
    if !self.masterKeyFingerprint.isEmpty {
      try visitor.visitSingularBytesField(value: self.masterKeyFingerprint, fieldNumber: 3)
    }
    if self.addressType != .unknown {
      try visitor.visitSingularEnumField(value: self.addressType, fieldNumber: 4)
    }
    if self.dryRun != false {
      try visitor.visitSingularBoolField(value: self.dryRun, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ImportAccountRequest, rhs: Walletrpc_ImportAccountRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.extendedPublicKey != rhs.extendedPublicKey {return false}
    if lhs.masterKeyFingerprint != rhs.masterKeyFingerprint {return false}
    if lhs.addressType != rhs.addressType {return false}
    if lhs.dryRun != rhs.dryRun {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ImportAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImportAccountResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .standard(proto: "dry_run_external_addrs"),
    3: .standard(proto: "dry_run_internal_addrs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.dryRunExternalAddrs) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.dryRunInternalAddrs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.dryRunExternalAddrs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.dryRunExternalAddrs, fieldNumber: 2)
    }
    if !self.dryRunInternalAddrs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.dryRunInternalAddrs, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ImportAccountResponse, rhs: Walletrpc_ImportAccountResponse) -> Bool {
    if lhs._account != rhs._account {return false}
    if lhs.dryRunExternalAddrs != rhs.dryRunExternalAddrs {return false}
    if lhs.dryRunInternalAddrs != rhs.dryRunInternalAddrs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ImportPublicKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImportPublicKeyRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
    2: .standard(proto: "address_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.addressType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 1)
    }
    if self.addressType != .unknown {
      try visitor.visitSingularEnumField(value: self.addressType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ImportPublicKeyRequest, rhs: Walletrpc_ImportPublicKeyRequest) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.addressType != rhs.addressType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ImportPublicKeyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImportPublicKeyResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ImportPublicKeyResponse, rhs: Walletrpc_ImportPublicKeyResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ImportTapscriptRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImportTapscriptRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "internal_public_key"),
    2: .standard(proto: "full_tree"),
    3: .standard(proto: "partial_reveal"),
    4: .standard(proto: "root_hash_only"),
    5: .standard(proto: "full_key_only"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.internalPublicKey) }()
      case 2: try {
        var v: Walletrpc_TapscriptFullTree?
        var hadOneofValue = false
        if let current = self.script {
          hadOneofValue = true
          if case .fullTree(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.script = .fullTree(v)
        }
      }()
      case 3: try {
        var v: Walletrpc_TapscriptPartialReveal?
        var hadOneofValue = false
        if let current = self.script {
          hadOneofValue = true
          if case .partialReveal(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.script = .partialReveal(v)
        }
      }()
      case 4: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.script != nil {try decoder.handleConflictingOneOf()}
          self.script = .rootHashOnly(v)
        }
      }()
      case 5: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.script != nil {try decoder.handleConflictingOneOf()}
          self.script = .fullKeyOnly(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.internalPublicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.internalPublicKey, fieldNumber: 1)
    }
    switch self.script {
    case .fullTree?: try {
      guard case .fullTree(let v)? = self.script else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .partialReveal?: try {
      guard case .partialReveal(let v)? = self.script else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .rootHashOnly?: try {
      guard case .rootHashOnly(let v)? = self.script else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }()
    case .fullKeyOnly?: try {
      guard case .fullKeyOnly(let v)? = self.script else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ImportTapscriptRequest, rhs: Walletrpc_ImportTapscriptRequest) -> Bool {
    if lhs.internalPublicKey != rhs.internalPublicKey {return false}
    if lhs.script != rhs.script {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_TapscriptFullTree: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TapscriptFullTree"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "all_leaves"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.allLeaves) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.allLeaves.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.allLeaves, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_TapscriptFullTree, rhs: Walletrpc_TapscriptFullTree) -> Bool {
    if lhs.allLeaves != rhs.allLeaves {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_TapLeaf: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TapLeaf"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "leaf_version"),
    2: .same(proto: "script"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.leafVersion) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.script) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.leafVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.leafVersion, fieldNumber: 1)
    }
    if !self.script.isEmpty {
      try visitor.visitSingularBytesField(value: self.script, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_TapLeaf, rhs: Walletrpc_TapLeaf) -> Bool {
    if lhs.leafVersion != rhs.leafVersion {return false}
    if lhs.script != rhs.script {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_TapscriptPartialReveal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TapscriptPartialReveal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "revealed_leaf"),
    2: .standard(proto: "full_inclusion_proof"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._revealedLeaf) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.fullInclusionProof) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._revealedLeaf {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.fullInclusionProof.isEmpty {
      try visitor.visitSingularBytesField(value: self.fullInclusionProof, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_TapscriptPartialReveal, rhs: Walletrpc_TapscriptPartialReveal) -> Bool {
    if lhs._revealedLeaf != rhs._revealedLeaf {return false}
    if lhs.fullInclusionProof != rhs.fullInclusionProof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ImportTapscriptResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImportTapscriptResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "p2tr_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.p2TrAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.p2TrAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.p2TrAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ImportTapscriptResponse, rhs: Walletrpc_ImportTapscriptResponse) -> Bool {
    if lhs.p2TrAddress != rhs.p2TrAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_Transaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Transaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_hex"),
    2: .same(proto: "label"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.txHex) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.label) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txHex.isEmpty {
      try visitor.visitSingularBytesField(value: self.txHex, fieldNumber: 1)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_Transaction, rhs: Walletrpc_Transaction) -> Bool {
    if lhs.txHex != rhs.txHex {return false}
    if lhs.label != rhs.label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_PublishResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PublishResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "publish_error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.publishError) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publishError.isEmpty {
      try visitor.visitSingularStringField(value: self.publishError, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_PublishResponse, rhs: Walletrpc_PublishResponse) -> Bool {
    if lhs.publishError != rhs.publishError {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_RemoveTransactionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoveTransactionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_RemoveTransactionResponse, rhs: Walletrpc_RemoveTransactionResponse) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_SendOutputsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendOutputsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sat_per_kw"),
    2: .same(proto: "outputs"),
    3: .same(proto: "label"),
    4: .standard(proto: "min_confs"),
    5: .standard(proto: "spend_unconfirmed"),
    6: .standard(proto: "coin_selection_strategy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.satPerKw) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.outputs) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.minConfs) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.spendUnconfirmed) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.coinSelectionStrategy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.satPerKw != 0 {
      try visitor.visitSingularInt64Field(value: self.satPerKw, fieldNumber: 1)
    }
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 2)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 3)
    }
    if self.minConfs != 0 {
      try visitor.visitSingularInt32Field(value: self.minConfs, fieldNumber: 4)
    }
    if self.spendUnconfirmed != false {
      try visitor.visitSingularBoolField(value: self.spendUnconfirmed, fieldNumber: 5)
    }
    if self.coinSelectionStrategy != .strategyUseGlobalConfig {
      try visitor.visitSingularEnumField(value: self.coinSelectionStrategy, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_SendOutputsRequest, rhs: Walletrpc_SendOutputsRequest) -> Bool {
    if lhs.satPerKw != rhs.satPerKw {return false}
    if lhs.outputs != rhs.outputs {return false}
    if lhs.label != rhs.label {return false}
    if lhs.minConfs != rhs.minConfs {return false}
    if lhs.spendUnconfirmed != rhs.spendUnconfirmed {return false}
    if lhs.coinSelectionStrategy != rhs.coinSelectionStrategy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_SendOutputsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendOutputsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_tx"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.rawTx) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rawTx.isEmpty {
      try visitor.visitSingularBytesField(value: self.rawTx, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_SendOutputsResponse, rhs: Walletrpc_SendOutputsResponse) -> Bool {
    if lhs.rawTx != rhs.rawTx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_EstimateFeeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EstimateFeeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "conf_target"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.confTarget) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.confTarget != 0 {
      try visitor.visitSingularInt32Field(value: self.confTarget, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_EstimateFeeRequest, rhs: Walletrpc_EstimateFeeRequest) -> Bool {
    if lhs.confTarget != rhs.confTarget {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_EstimateFeeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EstimateFeeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sat_per_kw"),
    2: .standard(proto: "min_relay_fee_sat_per_kw"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.satPerKw) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.minRelayFeeSatPerKw) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.satPerKw != 0 {
      try visitor.visitSingularInt64Field(value: self.satPerKw, fieldNumber: 1)
    }
    if self.minRelayFeeSatPerKw != 0 {
      try visitor.visitSingularInt64Field(value: self.minRelayFeeSatPerKw, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_EstimateFeeResponse, rhs: Walletrpc_EstimateFeeResponse) -> Bool {
    if lhs.satPerKw != rhs.satPerKw {return false}
    if lhs.minRelayFeeSatPerKw != rhs.minRelayFeeSatPerKw {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_PendingSweep: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PendingSweep"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "outpoint"),
    2: .standard(proto: "witness_type"),
    3: .standard(proto: "amount_sat"),
    4: .standard(proto: "sat_per_byte"),
    5: .standard(proto: "broadcast_attempts"),
    6: .standard(proto: "next_broadcast_height"),
    7: .same(proto: "force"),
    8: .standard(proto: "requested_conf_target"),
    9: .standard(proto: "requested_sat_per_byte"),
    10: .standard(proto: "sat_per_vbyte"),
    11: .standard(proto: "requested_sat_per_vbyte"),
    12: .same(proto: "immediate"),
    13: .same(proto: "budget"),
    14: .standard(proto: "deadline_height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._outpoint) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.witnessType) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.amountSat) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.satPerByte) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.broadcastAttempts) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.nextBroadcastHeight) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.requestedConfTarget) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.requestedSatPerByte) }()
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self.satPerVbyte) }()
      case 11: try { try decoder.decodeSingularUInt64Field(value: &self.requestedSatPerVbyte) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.immediate) }()
      case 13: try { try decoder.decodeSingularUInt64Field(value: &self.budget) }()
      case 14: try { try decoder.decodeSingularUInt32Field(value: &self.deadlineHeight) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._outpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.witnessType != .unknownWitness {
      try visitor.visitSingularEnumField(value: self.witnessType, fieldNumber: 2)
    }
    if self.amountSat != 0 {
      try visitor.visitSingularUInt32Field(value: self.amountSat, fieldNumber: 3)
    }
    if self.satPerByte != 0 {
      try visitor.visitSingularUInt32Field(value: self.satPerByte, fieldNumber: 4)
    }
    if self.broadcastAttempts != 0 {
      try visitor.visitSingularUInt32Field(value: self.broadcastAttempts, fieldNumber: 5)
    }
    if self.nextBroadcastHeight != 0 {
      try visitor.visitSingularUInt32Field(value: self.nextBroadcastHeight, fieldNumber: 6)
    }
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 7)
    }
    if self.requestedConfTarget != 0 {
      try visitor.visitSingularUInt32Field(value: self.requestedConfTarget, fieldNumber: 8)
    }
    if self.requestedSatPerByte != 0 {
      try visitor.visitSingularUInt32Field(value: self.requestedSatPerByte, fieldNumber: 9)
    }
    if self.satPerVbyte != 0 {
      try visitor.visitSingularUInt64Field(value: self.satPerVbyte, fieldNumber: 10)
    }
    if self.requestedSatPerVbyte != 0 {
      try visitor.visitSingularUInt64Field(value: self.requestedSatPerVbyte, fieldNumber: 11)
    }
    if self.immediate != false {
      try visitor.visitSingularBoolField(value: self.immediate, fieldNumber: 12)
    }
    if self.budget != 0 {
      try visitor.visitSingularUInt64Field(value: self.budget, fieldNumber: 13)
    }
    if self.deadlineHeight != 0 {
      try visitor.visitSingularUInt32Field(value: self.deadlineHeight, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_PendingSweep, rhs: Walletrpc_PendingSweep) -> Bool {
    if lhs._outpoint != rhs._outpoint {return false}
    if lhs.witnessType != rhs.witnessType {return false}
    if lhs.amountSat != rhs.amountSat {return false}
    if lhs.satPerByte != rhs.satPerByte {return false}
    if lhs.broadcastAttempts != rhs.broadcastAttempts {return false}
    if lhs.nextBroadcastHeight != rhs.nextBroadcastHeight {return false}
    if lhs.force != rhs.force {return false}
    if lhs.requestedConfTarget != rhs.requestedConfTarget {return false}
    if lhs.requestedSatPerByte != rhs.requestedSatPerByte {return false}
    if lhs.satPerVbyte != rhs.satPerVbyte {return false}
    if lhs.requestedSatPerVbyte != rhs.requestedSatPerVbyte {return false}
    if lhs.immediate != rhs.immediate {return false}
    if lhs.budget != rhs.budget {return false}
    if lhs.deadlineHeight != rhs.deadlineHeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_PendingSweepsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PendingSweepsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_PendingSweepsRequest, rhs: Walletrpc_PendingSweepsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_PendingSweepsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PendingSweepsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pending_sweeps"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.pendingSweeps) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pendingSweeps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pendingSweeps, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_PendingSweepsResponse, rhs: Walletrpc_PendingSweepsResponse) -> Bool {
    if lhs.pendingSweeps != rhs.pendingSweeps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_BumpFeeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BumpFeeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "outpoint"),
    2: .standard(proto: "target_conf"),
    3: .standard(proto: "sat_per_byte"),
    4: .same(proto: "force"),
    5: .standard(proto: "sat_per_vbyte"),
    6: .same(proto: "immediate"),
    7: .same(proto: "budget"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._outpoint) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.targetConf) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.satPerByte) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.satPerVbyte) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.immediate) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.budget) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._outpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.targetConf != 0 {
      try visitor.visitSingularUInt32Field(value: self.targetConf, fieldNumber: 2)
    }
    if self.satPerByte != 0 {
      try visitor.visitSingularUInt32Field(value: self.satPerByte, fieldNumber: 3)
    }
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 4)
    }
    if self.satPerVbyte != 0 {
      try visitor.visitSingularUInt64Field(value: self.satPerVbyte, fieldNumber: 5)
    }
    if self.immediate != false {
      try visitor.visitSingularBoolField(value: self.immediate, fieldNumber: 6)
    }
    if self.budget != 0 {
      try visitor.visitSingularUInt64Field(value: self.budget, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_BumpFeeRequest, rhs: Walletrpc_BumpFeeRequest) -> Bool {
    if lhs._outpoint != rhs._outpoint {return false}
    if lhs.targetConf != rhs.targetConf {return false}
    if lhs.satPerByte != rhs.satPerByte {return false}
    if lhs.force != rhs.force {return false}
    if lhs.satPerVbyte != rhs.satPerVbyte {return false}
    if lhs.immediate != rhs.immediate {return false}
    if lhs.budget != rhs.budget {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_BumpFeeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BumpFeeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_BumpFeeResponse, rhs: Walletrpc_BumpFeeResponse) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ListSweepsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListSweepsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "verbose"),
    2: .standard(proto: "start_height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.verbose) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.startHeight) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.verbose != false {
      try visitor.visitSingularBoolField(value: self.verbose, fieldNumber: 1)
    }
    if self.startHeight != 0 {
      try visitor.visitSingularInt32Field(value: self.startHeight, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ListSweepsRequest, rhs: Walletrpc_ListSweepsRequest) -> Bool {
    if lhs.verbose != rhs.verbose {return false}
    if lhs.startHeight != rhs.startHeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ListSweepsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListSweepsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_details"),
    2: .standard(proto: "transaction_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Lnrpc_TransactionDetails?
        var hadOneofValue = false
        if let current = self.sweeps {
          hadOneofValue = true
          if case .transactionDetails(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.sweeps = .transactionDetails(v)
        }
      }()
      case 2: try {
        var v: Walletrpc_ListSweepsResponse.TransactionIDs?
        var hadOneofValue = false
        if let current = self.sweeps {
          hadOneofValue = true
          if case .transactionIds(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.sweeps = .transactionIds(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.sweeps {
    case .transactionDetails?: try {
      guard case .transactionDetails(let v)? = self.sweeps else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .transactionIds?: try {
      guard case .transactionIds(let v)? = self.sweeps else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ListSweepsResponse, rhs: Walletrpc_ListSweepsResponse) -> Bool {
    if lhs.sweeps != rhs.sweeps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ListSweepsResponse.TransactionIDs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Walletrpc_ListSweepsResponse.protoMessageName + ".TransactionIDs"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.transactionIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.transactionIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ListSweepsResponse.TransactionIDs, rhs: Walletrpc_ListSweepsResponse.TransactionIDs) -> Bool {
    if lhs.transactionIds != rhs.transactionIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_LabelTransactionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LabelTransactionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txid"),
    2: .same(proto: "label"),
    3: .same(proto: "overwrite"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.txid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.overwrite) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txid.isEmpty {
      try visitor.visitSingularBytesField(value: self.txid, fieldNumber: 1)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 2)
    }
    if self.overwrite != false {
      try visitor.visitSingularBoolField(value: self.overwrite, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_LabelTransactionRequest, rhs: Walletrpc_LabelTransactionRequest) -> Bool {
    if lhs.txid != rhs.txid {return false}
    if lhs.label != rhs.label {return false}
    if lhs.overwrite != rhs.overwrite {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_LabelTransactionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LabelTransactionResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_LabelTransactionResponse, rhs: Walletrpc_LabelTransactionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_FundPsbtRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FundPsbtRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "psbt"),
    2: .same(proto: "raw"),
    9: .standard(proto: "coin_select"),
    3: .standard(proto: "target_conf"),
    4: .standard(proto: "sat_per_vbyte"),
    5: .same(proto: "account"),
    6: .standard(proto: "min_confs"),
    7: .standard(proto: "spend_unconfirmed"),
    8: .standard(proto: "change_type"),
    10: .standard(proto: "coin_selection_strategy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.template != nil {try decoder.handleConflictingOneOf()}
          self.template = .psbt(v)
        }
      }()
      case 2: try {
        var v: Walletrpc_TxTemplate?
        var hadOneofValue = false
        if let current = self.template {
          hadOneofValue = true
          if case .raw(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.template = .raw(v)
        }
      }()
      case 3: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.fees != nil {try decoder.handleConflictingOneOf()}
          self.fees = .targetConf(v)
        }
      }()
      case 4: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.fees != nil {try decoder.handleConflictingOneOf()}
          self.fees = .satPerVbyte(v)
        }
      }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.minConfs) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.spendUnconfirmed) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.changeType) }()
      case 9: try {
        var v: Walletrpc_PsbtCoinSelect?
        var hadOneofValue = false
        if let current = self.template {
          hadOneofValue = true
          if case .coinSelect(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.template = .coinSelect(v)
        }
      }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.coinSelectionStrategy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.template {
    case .psbt?: try {
      guard case .psbt(let v)? = self.template else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .raw?: try {
      guard case .raw(let v)? = self.template else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    default: break
    }
    switch self.fees {
    case .targetConf?: try {
      guard case .targetConf(let v)? = self.fees else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }()
    case .satPerVbyte?: try {
      guard case .satPerVbyte(let v)? = self.fees else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 5)
    }
    if self.minConfs != 0 {
      try visitor.visitSingularInt32Field(value: self.minConfs, fieldNumber: 6)
    }
    if self.spendUnconfirmed != false {
      try visitor.visitSingularBoolField(value: self.spendUnconfirmed, fieldNumber: 7)
    }
    if self.changeType != .unspecified {
      try visitor.visitSingularEnumField(value: self.changeType, fieldNumber: 8)
    }
    try { if case .coinSelect(let v)? = self.template {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    if self.coinSelectionStrategy != .strategyUseGlobalConfig {
      try visitor.visitSingularEnumField(value: self.coinSelectionStrategy, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_FundPsbtRequest, rhs: Walletrpc_FundPsbtRequest) -> Bool {
    if lhs.template != rhs.template {return false}
    if lhs.fees != rhs.fees {return false}
    if lhs.account != rhs.account {return false}
    if lhs.minConfs != rhs.minConfs {return false}
    if lhs.spendUnconfirmed != rhs.spendUnconfirmed {return false}
    if lhs.changeType != rhs.changeType {return false}
    if lhs.coinSelectionStrategy != rhs.coinSelectionStrategy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_FundPsbtResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FundPsbtResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "funded_psbt"),
    2: .standard(proto: "change_output_index"),
    3: .standard(proto: "locked_utxos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.fundedPsbt) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.changeOutputIndex) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.lockedUtxos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fundedPsbt.isEmpty {
      try visitor.visitSingularBytesField(value: self.fundedPsbt, fieldNumber: 1)
    }
    if self.changeOutputIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.changeOutputIndex, fieldNumber: 2)
    }
    if !self.lockedUtxos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lockedUtxos, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_FundPsbtResponse, rhs: Walletrpc_FundPsbtResponse) -> Bool {
    if lhs.fundedPsbt != rhs.fundedPsbt {return false}
    if lhs.changeOutputIndex != rhs.changeOutputIndex {return false}
    if lhs.lockedUtxos != rhs.lockedUtxos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_TxTemplate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TxTemplate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputs"),
    2: .same(proto: "outputs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt64>.self, value: &self.outputs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 1)
    }
    if !self.outputs.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt64>.self, value: self.outputs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_TxTemplate, rhs: Walletrpc_TxTemplate) -> Bool {
    if lhs.inputs != rhs.inputs {return false}
    if lhs.outputs != rhs.outputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_PsbtCoinSelect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PsbtCoinSelect"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "psbt"),
    2: .standard(proto: "existing_output_index"),
    3: .same(proto: "add"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.psbt) }()
      case 2: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.changeOutput != nil {try decoder.handleConflictingOneOf()}
          self.changeOutput = .existingOutputIndex(v)
        }
      }()
      case 3: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.changeOutput != nil {try decoder.handleConflictingOneOf()}
          self.changeOutput = .add(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.psbt.isEmpty {
      try visitor.visitSingularBytesField(value: self.psbt, fieldNumber: 1)
    }
    switch self.changeOutput {
    case .existingOutputIndex?: try {
      guard case .existingOutputIndex(let v)? = self.changeOutput else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }()
    case .add?: try {
      guard case .add(let v)? = self.changeOutput else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_PsbtCoinSelect, rhs: Walletrpc_PsbtCoinSelect) -> Bool {
    if lhs.psbt != rhs.psbt {return false}
    if lhs.changeOutput != rhs.changeOutput {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_UtxoLease: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UtxoLease"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "outpoint"),
    3: .same(proto: "expiration"),
    4: .standard(proto: "pk_script"),
    5: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._outpoint) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.expiration) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.pkScript) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._outpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.expiration != 0 {
      try visitor.visitSingularUInt64Field(value: self.expiration, fieldNumber: 3)
    }
    if !self.pkScript.isEmpty {
      try visitor.visitSingularBytesField(value: self.pkScript, fieldNumber: 4)
    }
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_UtxoLease, rhs: Walletrpc_UtxoLease) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._outpoint != rhs._outpoint {return false}
    if lhs.expiration != rhs.expiration {return false}
    if lhs.pkScript != rhs.pkScript {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_SignPsbtRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignPsbtRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "funded_psbt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.fundedPsbt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fundedPsbt.isEmpty {
      try visitor.visitSingularBytesField(value: self.fundedPsbt, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_SignPsbtRequest, rhs: Walletrpc_SignPsbtRequest) -> Bool {
    if lhs.fundedPsbt != rhs.fundedPsbt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_SignPsbtResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignPsbtResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "signed_psbt"),
    2: .standard(proto: "signed_inputs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.signedPsbt) }()
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.signedInputs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signedPsbt.isEmpty {
      try visitor.visitSingularBytesField(value: self.signedPsbt, fieldNumber: 1)
    }
    if !self.signedInputs.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.signedInputs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_SignPsbtResponse, rhs: Walletrpc_SignPsbtResponse) -> Bool {
    if lhs.signedPsbt != rhs.signedPsbt {return false}
    if lhs.signedInputs != rhs.signedInputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_FinalizePsbtRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FinalizePsbtRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "funded_psbt"),
    5: .same(proto: "account"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.fundedPsbt) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.account) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fundedPsbt.isEmpty {
      try visitor.visitSingularBytesField(value: self.fundedPsbt, fieldNumber: 1)
    }
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_FinalizePsbtRequest, rhs: Walletrpc_FinalizePsbtRequest) -> Bool {
    if lhs.fundedPsbt != rhs.fundedPsbt {return false}
    if lhs.account != rhs.account {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_FinalizePsbtResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FinalizePsbtResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "signed_psbt"),
    2: .standard(proto: "raw_final_tx"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.signedPsbt) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.rawFinalTx) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signedPsbt.isEmpty {
      try visitor.visitSingularBytesField(value: self.signedPsbt, fieldNumber: 1)
    }
    if !self.rawFinalTx.isEmpty {
      try visitor.visitSingularBytesField(value: self.rawFinalTx, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_FinalizePsbtResponse, rhs: Walletrpc_FinalizePsbtResponse) -> Bool {
    if lhs.signedPsbt != rhs.signedPsbt {return false}
    if lhs.rawFinalTx != rhs.rawFinalTx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ListLeasesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListLeasesRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ListLeasesRequest, rhs: Walletrpc_ListLeasesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ListLeasesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListLeasesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "locked_utxos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.lockedUtxos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lockedUtxos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lockedUtxos, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ListLeasesResponse, rhs: Walletrpc_ListLeasesResponse) -> Bool {
    if lhs.lockedUtxos != rhs.lockedUtxos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
