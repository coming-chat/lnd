// Code generated by falafel 0.9.2. DO NOT EDIT.
// source: ./chainkit_api_generated.go

//go:build chainrpc
// +build chainrpc

package lndmobile

import (
	"context"
	"net"

	"github.com/golang/protobuf/proto"
	"google.golang.org/grpc"

	"github.com/lightningnetwork/lnd/lnrpc/chainrpc"
)

// setChainKitDialOption sets the given method as the way
// to retrieve gprc options for the service.
func setChainKitDialOption(f func() ([]grpc.DialOption, error)) {
	serviceDialOptionsMtx.Lock()
	defer serviceDialOptionsMtx.Unlock()

	serviceDialOptions["ChainKit"] = f
}

// applyChainKitDialOptions returns extra grpc options to
// use when calling the service.
func applyChainKitDialOptions() ([]grpc.DialOption, error) {
	serviceDialOptionsMtx.Lock()
	defer serviceDialOptionsMtx.Unlock()

	// First check the service options map, if there are any options
	// specific to this service.
	f, ok := serviceDialOptions["ChainKit"]
	if ok {
		return f()
	}

	// Otherwise return the default options.
	return defaultDialOptions()
}

// getChainKitConn dials ChainKit with the current dial options,
// and returns the grpc client connection.
func getChainKitConn() (*grpc.ClientConn, func(), error) {
	conn, err := lightningLis.Dial()
	if err != nil {
		return nil, nil, err
	}

	// Set up a custom dialer using the listener conn.
	dialer := func(context.Context, string) (net.Conn, error) {
		return conn, nil
	}

	// Create a dial options array.
	opts := []grpc.DialOption{
		grpc.WithContextDialer(dialer),
	}

	// Apply any extra server options.
	extraOpts, err := applyChainKitDialOptions()
	if err != nil {
		return nil, nil, err
	}

	opts = append(opts, extraOpts...)

	// As address we use "localhost" to mimic a local connection.
	address := "localhost"
	clientConn, err := grpc.Dial(address, opts...)
	if err != nil {
		conn.Close()
		return nil, nil, err
	}

	closeConn := func() {
		conn.Close()
	}

	return clientConn, closeConn, nil
}

// getChainKitClient returns a client connection to the server listening
// on lis.
func getChainKitClient() (chainrpc.ChainKitClient, func(), error) {
	clientConn, closeConn, err := getChainKitConn()
	if err != nil {
		return nil, nil, err
	}
	client := chainrpc.NewChainKitClient(clientConn)
	return client, closeConn, nil
}

// GetBlock returns a block given the corresponding block hash.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func ChainKitGetBlock(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &chainrpc.GetBlockRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getChainKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*chainrpc.GetBlockRequest)
			return client.GetBlock(ctx, r)
		},
	}
	s.start(msg, callback)
}

// GetBlockHeader returns a block header with a particular block hash.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func ChainKitGetBlockHeader(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &chainrpc.GetBlockHeaderRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getChainKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*chainrpc.GetBlockHeaderRequest)
			return client.GetBlockHeader(ctx, r)
		},
	}
	s.start(msg, callback)
}

// GetBestBlock returns the block hash and current height from the valid
// most-work chain.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func ChainKitGetBestBlock(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &chainrpc.GetBestBlockRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getChainKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*chainrpc.GetBestBlockRequest)
			return client.GetBestBlock(ctx, r)
		},
	}
	s.start(msg, callback)
}

// GetBlockHash returns the hash of the block in the best blockchain
// at the given height.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func ChainKitGetBlockHash(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &chainrpc.GetBlockHashRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getChainKitClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*chainrpc.GetBlockHashRequest)
			return client.GetBlockHash(ctx, r)
		},
	}
	s.start(msg, callback)
}
