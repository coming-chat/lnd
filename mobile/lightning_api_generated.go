// Code generated by falafel 0.9.2. DO NOT EDIT.
// source: ./lightning_api_generated.go

package lndmobile

import (
	"context"
	"net"

	"github.com/golang/protobuf/proto"
	"google.golang.org/grpc"

	"github.com/lightningnetwork/lnd/lnrpc"
)

// setLightningDialOption sets the given method as the way
// to retrieve gprc options for the service.
func setLightningDialOption(f func() ([]grpc.DialOption, error)) {
	serviceDialOptionsMtx.Lock()
	defer serviceDialOptionsMtx.Unlock()

	serviceDialOptions["Lightning"] = f
}

// applyLightningDialOptions returns extra grpc options to
// use when calling the service.
func applyLightningDialOptions() ([]grpc.DialOption, error) {
	serviceDialOptionsMtx.Lock()
	defer serviceDialOptionsMtx.Unlock()

	// First check the service options map, if there are any options
	// specific to this service.
	f, ok := serviceDialOptions["Lightning"]
	if ok {
		return f()
	}

	// Otherwise return the default options.
	return defaultDialOptions()
}

// getLightningConn dials Lightning with the current dial options,
// and returns the grpc client connection.
func getLightningConn() (*grpc.ClientConn, func(), error) {
	conn, err := lightningLis.Dial()
	if err != nil {
		return nil, nil, err
	}

	// Set up a custom dialer using the listener conn.
	dialer := func(context.Context, string) (net.Conn, error) {
		return conn, nil
	}

	// Create a dial options array.
	opts := []grpc.DialOption{
		grpc.WithContextDialer(dialer),
	}

	// Apply any extra server options.
	extraOpts, err := applyLightningDialOptions()
	if err != nil {
		return nil, nil, err
	}

	opts = append(opts, extraOpts...)

	// As address we use "localhost" to mimic a local connection.
	address := "localhost"
	clientConn, err := grpc.Dial(address, opts...)
	if err != nil {
		conn.Close()
		return nil, nil, err
	}

	closeConn := func() {
		conn.Close()
	}

	return clientConn, closeConn, nil
}

// getLightningClient returns a client connection to the server listening
// on lis.
func getLightningClient() (lnrpc.LightningClient, func(), error) {
	clientConn, closeConn, err := getLightningConn()
	if err != nil {
		return nil, nil, err
	}
	client := lnrpc.NewLightningClient(clientConn)
	return client, closeConn, nil
}

// WalletBalance returns total unspent outputs(confirmed and unconfirmed), all
// confirmed unspent outputs and all unconfirmed unspent outputs under control
// of the wallet.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func WalletBalance(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.WalletBalanceRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.WalletBalanceRequest)
			return client.WalletBalance(ctx, r)
		},
	}
	s.start(msg, callback)
}

// ChannelBalance returns a report on the total funds across all open channels,
// categorized in local/remote, pending local/remote and unsettled local/remote
// balances.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func ChannelBalance(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.ChannelBalanceRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.ChannelBalanceRequest)
			return client.ChannelBalance(ctx, r)
		},
	}
	s.start(msg, callback)
}

// GetTransactions returns a list describing all the known transactions
// relevant to the wallet.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func GetTransactions(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.GetTransactionsRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.GetTransactionsRequest)
			return client.GetTransactions(ctx, r)
		},
	}
	s.start(msg, callback)
}

// EstimateFee asks the chain backend to estimate the fee rate and total fees
// for a transaction that pays to multiple specified outputs.
//
// When using REST, the `AddrToAmount` map type can be set by appending
// `&AddrToAmount[<address>]=<amount_to_send>` to the URL. Unfortunately this
// map type doesn't appear in the REST API documentation because of a bug in
// the grpc-gateway library.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func EstimateFee(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.EstimateFeeRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.EstimateFeeRequest)
			return client.EstimateFee(ctx, r)
		},
	}
	s.start(msg, callback)
}

// SendCoins executes a request to send coins to a particular address. Unlike
// SendMany, this RPC call only allows creating a single output at a time. If
// neither target_conf, or sat_per_vbyte are set, then the internal wallet will
// consult its fee model to determine a fee for the default confirmation
// target.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func SendCoins(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.SendCoinsRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.SendCoinsRequest)
			return client.SendCoins(ctx, r)
		},
	}
	s.start(msg, callback)
}

// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func ListUnspent(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.ListUnspentRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.ListUnspentRequest)
			return client.ListUnspent(ctx, r)
		},
	}
	s.start(msg, callback)
}

// SubscribeTransactions creates a uni-directional stream from the server to
// the client in which any newly discovered transactions relevant to the
// wallet are sent over.
//
// NOTE: This method produces a stream of responses, and the receive stream can
// be called zero or more times. After EOF error is returned, no more responses
// will be produced.
func SubscribeTransactions(msg []byte, rStream RecvStream) {
	s := &readStreamHandler{
		newProto: func() proto.Message {
			return &lnrpc.GetTransactionsRequest{}
		},
		recvStream: func(ctx context.Context,
			req proto.Message) (*receiver, func(), error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, nil, err
			}

			r := req.(*lnrpc.GetTransactionsRequest)
			stream, err := client.SubscribeTransactions(ctx, r)
			if err != nil {
				closeClient()
				return nil, nil, err
			}
			return &receiver{
				recv: func() (proto.Message, error) {
					return stream.Recv()
				},
			}, closeClient, nil
		},
	}
	s.start(msg, rStream)
}

// SendMany handles a request for a transaction that creates multiple specified
// outputs in parallel. If neither target_conf, or sat_per_vbyte are set, then
// the internal wallet will consult its fee model to determine a fee for the
// default confirmation target.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func SendMany(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.SendManyRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.SendManyRequest)
			return client.SendMany(ctx, r)
		},
	}
	s.start(msg, callback)
}

// NewAddress creates a new address under control of the local wallet.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func NewAddress(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.NewAddressRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.NewAddressRequest)
			return client.NewAddress(ctx, r)
		},
	}
	s.start(msg, callback)
}

// SignMessage signs a message with this node's private key. The returned
// signature string is `zbase32` encoded and pubkey recoverable, meaning that
// only the message digest and signature are needed for verification.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func SignMessage(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.SignMessageRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.SignMessageRequest)
			return client.SignMessage(ctx, r)
		},
	}
	s.start(msg, callback)
}

// VerifyMessage verifies a signature over a message and recovers the signer's
// public key. The signature is only deemed valid if the recovered public key
// corresponds to a node key in the public Lightning network. The signature
// must be zbase32 encoded and signed by an active node in the resident node's
// channel database. In addition to returning the validity of the signature,
// VerifyMessage also returns the recovered pubkey from the signature.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func VerifyMessage(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.VerifyMessageRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.VerifyMessageRequest)
			return client.VerifyMessage(ctx, r)
		},
	}
	s.start(msg, callback)
}

// ConnectPeer attempts to establish a connection to a remote peer. This is at
// the networking level, and is used for communication between nodes. This is
// distinct from establishing a channel with a peer.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func ConnectPeer(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.ConnectPeerRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.ConnectPeerRequest)
			return client.ConnectPeer(ctx, r)
		},
	}
	s.start(msg, callback)
}

// DisconnectPeer attempts to disconnect one peer from another identified by a
// given pubKey. In the case that we currently have a pending or active channel
// with the target peer, then this action will be not be allowed.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func DisconnectPeer(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.DisconnectPeerRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.DisconnectPeerRequest)
			return client.DisconnectPeer(ctx, r)
		},
	}
	s.start(msg, callback)
}

// ListPeers returns a verbose listing of all currently active peers.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func ListPeers(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.ListPeersRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.ListPeersRequest)
			return client.ListPeers(ctx, r)
		},
	}
	s.start(msg, callback)
}

// SubscribePeerEvents creates a uni-directional stream from the server to
// the client in which any events relevant to the state of peers are sent
// over. Events include peers going online and offline.
//
// NOTE: This method produces a stream of responses, and the receive stream can
// be called zero or more times. After EOF error is returned, no more responses
// will be produced.
func SubscribePeerEvents(msg []byte, rStream RecvStream) {
	s := &readStreamHandler{
		newProto: func() proto.Message {
			return &lnrpc.PeerEventSubscription{}
		},
		recvStream: func(ctx context.Context,
			req proto.Message) (*receiver, func(), error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, nil, err
			}

			r := req.(*lnrpc.PeerEventSubscription)
			stream, err := client.SubscribePeerEvents(ctx, r)
			if err != nil {
				closeClient()
				return nil, nil, err
			}
			return &receiver{
				recv: func() (proto.Message, error) {
					return stream.Recv()
				},
			}, closeClient, nil
		},
	}
	s.start(msg, rStream)
}

// GetInfo returns general information concerning the lightning node including
// it's identity pubkey, alias, the chains it is connected to, and information
// concerning the number of open+pending channels.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func GetInfo(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.GetInfoRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.GetInfoRequest)
			return client.GetInfo(ctx, r)
		},
	}
	s.start(msg, callback)
}

// GetDebugInfo returns debug information concerning the state of the daemon
// and its subsystems. This includes the full configuration and the latest log
// entries from the log file.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func GetDebugInfo(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.GetDebugInfoRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.GetDebugInfoRequest)
			return client.GetDebugInfo(ctx, r)
		},
	}
	s.start(msg, callback)
}

// GetRecoveryInfo returns information concerning the recovery mode including
// whether it's in a recovery mode, whether the recovery is finished, and the
// progress made so far.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func GetRecoveryInfo(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.GetRecoveryInfoRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.GetRecoveryInfoRequest)
			return client.GetRecoveryInfo(ctx, r)
		},
	}
	s.start(msg, callback)
}

// PendingChannels returns a list of all the channels that are currently
// considered "pending". A channel is pending if it has finished the funding
// workflow and is waiting for confirmations for the funding txn, or is in the
// process of closure, either initiated cooperatively or non-cooperatively.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func PendingChannels(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.PendingChannelsRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.PendingChannelsRequest)
			return client.PendingChannels(ctx, r)
		},
	}
	s.start(msg, callback)
}

// ListChannels returns a description of all the open channels that this node
// is a participant in.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func ListChannels(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.ListChannelsRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.ListChannelsRequest)
			return client.ListChannels(ctx, r)
		},
	}
	s.start(msg, callback)
}

// SubscribeChannelEvents creates a uni-directional stream from the server to
// the client in which any updates relevant to the state of the channels are
// sent over. Events include new active channels, inactive channels, and closed
// channels.
//
// NOTE: This method produces a stream of responses, and the receive stream can
// be called zero or more times. After EOF error is returned, no more responses
// will be produced.
func SubscribeChannelEvents(msg []byte, rStream RecvStream) {
	s := &readStreamHandler{
		newProto: func() proto.Message {
			return &lnrpc.ChannelEventSubscription{}
		},
		recvStream: func(ctx context.Context,
			req proto.Message) (*receiver, func(), error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, nil, err
			}

			r := req.(*lnrpc.ChannelEventSubscription)
			stream, err := client.SubscribeChannelEvents(ctx, r)
			if err != nil {
				closeClient()
				return nil, nil, err
			}
			return &receiver{
				recv: func() (proto.Message, error) {
					return stream.Recv()
				},
			}, closeClient, nil
		},
	}
	s.start(msg, rStream)
}

// ClosedChannels returns a description of all the closed channels that
// this node was a participant in.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func ClosedChannels(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.ClosedChannelsRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.ClosedChannelsRequest)
			return client.ClosedChannels(ctx, r)
		},
	}
	s.start(msg, callback)
}

// OpenChannelSync is a synchronous version of the OpenChannel RPC call. This
// call is meant to be consumed by clients to the REST proxy. As with all
// other sync calls, all byte slices are intended to be populated as hex
// encoded strings.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func OpenChannelSync(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.OpenChannelRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.OpenChannelRequest)
			return client.OpenChannelSync(ctx, r)
		},
	}
	s.start(msg, callback)
}

// OpenChannel attempts to open a singly funded channel specified in the
// request to a remote peer. Users are able to specify a target number of
// blocks that the funding transaction should be confirmed in, or a manual fee
// rate to us for the funding transaction. If neither are specified, then a
// lax block confirmation target is used. Each OpenStatusUpdate will return
// the pending channel ID of the in-progress channel. Depending on the
// arguments specified in the OpenChannelRequest, this pending channel ID can
// then be used to manually progress the channel funding flow.
//
// NOTE: This method produces a stream of responses, and the receive stream can
// be called zero or more times. After EOF error is returned, no more responses
// will be produced.
func OpenChannel(msg []byte, rStream RecvStream) {
	s := &readStreamHandler{
		newProto: func() proto.Message {
			return &lnrpc.OpenChannelRequest{}
		},
		recvStream: func(ctx context.Context,
			req proto.Message) (*receiver, func(), error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, nil, err
			}

			r := req.(*lnrpc.OpenChannelRequest)
			stream, err := client.OpenChannel(ctx, r)
			if err != nil {
				closeClient()
				return nil, nil, err
			}
			return &receiver{
				recv: func() (proto.Message, error) {
					return stream.Recv()
				},
			}, closeClient, nil
		},
	}
	s.start(msg, rStream)
}

// BatchOpenChannel attempts to open multiple single-funded channels in a
// single transaction in an atomic way. This means either all channel open
// requests succeed at once or all attempts are aborted if any of them fail.
// This is the safer variant of using PSBTs to manually fund a batch of
// channels through the OpenChannel RPC.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func BatchOpenChannel(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.BatchOpenChannelRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.BatchOpenChannelRequest)
			return client.BatchOpenChannel(ctx, r)
		},
	}
	s.start(msg, callback)
}

// FundingStateStep is an advanced funding related call that allows the caller
// to either execute some preparatory steps for a funding workflow, or
// manually progress a funding workflow. The primary way a funding flow is
// identified is via its pending channel ID. As an example, this method can be
// used to specify that we're expecting a funding flow for a particular
// pending channel ID, for which we need to use specific parameters.
// Alternatively, this can be used to interactively drive PSBT signing for
// funding for partially complete funding transactions.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func FundingStateStep(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.FundingTransitionMsg{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.FundingTransitionMsg)
			return client.FundingStateStep(ctx, r)
		},
	}
	s.start(msg, callback)
}

// ChannelAcceptor dispatches a bi-directional streaming RPC in which
// OpenChannel requests are sent to the client and the client responds with
// a boolean that tells LND whether or not to accept the channel. This allows
// node operators to specify their own criteria for accepting inbound channels
// through a single persistent connection.
//
// NOTE: This method produces a stream of responses, and the receive stream can
// be called zero or more times. After EOF error is returned, no more responses
// will be produced. The send stream can accept zero or more requests before it
// is closed.
func ChannelAcceptor(rStream RecvStream) (SendStream, error) {
	b := &biStreamHandler{
		newProto: func() proto.Message {
			return &lnrpc.ChannelAcceptResponse{}
		},
		biStream: func(ctx context.Context) (*receiver, *sender, func(), error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, nil, nil, err
			}

			stream, err := client.ChannelAcceptor(ctx)
			if err != nil {
				closeClient()
				return nil, nil, nil, err
			}
			return &receiver{
					recv: func() (proto.Message, error) {
						return stream.Recv()
					},
				},
				&sender{
					send: func(req proto.Message) error {
						r := req.(*lnrpc.ChannelAcceptResponse)
						return stream.Send(r)
					},
					closeStream: stream.CloseSend,
				}, closeClient, nil
		},
	}
	return b.start(rStream)
}

// CloseChannel attempts to close an active channel identified by its channel
// outpoint (ChannelPoint). The actions of this method can additionally be
// augmented to attempt a force close after a timeout period in the case of an
// inactive peer. If a non-force close (cooperative closure) is requested,
// then the user can specify either a target number of blocks until the
// closure transaction is confirmed, or a manual fee rate. If neither are
// specified, then a default lax, block confirmation target is used.
//
// NOTE: This method produces a stream of responses, and the receive stream can
// be called zero or more times. After EOF error is returned, no more responses
// will be produced.
func CloseChannel(msg []byte, rStream RecvStream) {
	s := &readStreamHandler{
		newProto: func() proto.Message {
			return &lnrpc.CloseChannelRequest{}
		},
		recvStream: func(ctx context.Context,
			req proto.Message) (*receiver, func(), error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, nil, err
			}

			r := req.(*lnrpc.CloseChannelRequest)
			stream, err := client.CloseChannel(ctx, r)
			if err != nil {
				closeClient()
				return nil, nil, err
			}
			return &receiver{
				recv: func() (proto.Message, error) {
					return stream.Recv()
				},
			}, closeClient, nil
		},
	}
	s.start(msg, rStream)
}

// AbandonChannel removes all channel state from the database except for a
// close summary. This method can be used to get rid of permanently unusable
// channels due to bugs fixed in newer versions of lnd. This method can also be
// used to remove externally funded channels where the funding transaction was
// never broadcast. Only available for non-externally funded channels in dev
// build.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func AbandonChannel(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.AbandonChannelRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.AbandonChannelRequest)
			return client.AbandonChannel(ctx, r)
		},
	}
	s.start(msg, callback)
}

// NOTE: This method produces a stream of responses, and the receive stream can
// be called zero or more times. After EOF error is returned, no more responses
// will be produced. The send stream can accept zero or more requests before it
// is closed.
func SendPayment(rStream RecvStream) (SendStream, error) {
	b := &biStreamHandler{
		newProto: func() proto.Message {
			return &lnrpc.SendRequest{}
		},
		biStream: func(ctx context.Context) (*receiver, *sender, func(), error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, nil, nil, err
			}

			stream, err := client.SendPayment(ctx)
			if err != nil {
				closeClient()
				return nil, nil, nil, err
			}
			return &receiver{
					recv: func() (proto.Message, error) {
						return stream.Recv()
					},
				},
				&sender{
					send: func(req proto.Message) error {
						r := req.(*lnrpc.SendRequest)
						return stream.Send(r)
					},
					closeStream: stream.CloseSend,
				}, closeClient, nil
		},
	}
	return b.start(rStream)
}

// SendPaymentSync is the synchronous non-streaming version of SendPayment.
// This RPC is intended to be consumed by clients of the REST proxy.
// Additionally, this RPC expects the destination's public key and the payment
// hash (if any) to be encoded as hex strings.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func SendPaymentSync(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.SendRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.SendRequest)
			return client.SendPaymentSync(ctx, r)
		},
	}
	s.start(msg, callback)
}

// NOTE: This method produces a stream of responses, and the receive stream can
// be called zero or more times. After EOF error is returned, no more responses
// will be produced. The send stream can accept zero or more requests before it
// is closed.
func SendToRoute(rStream RecvStream) (SendStream, error) {
	b := &biStreamHandler{
		newProto: func() proto.Message {
			return &lnrpc.SendToRouteRequest{}
		},
		biStream: func(ctx context.Context) (*receiver, *sender, func(), error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, nil, nil, err
			}

			stream, err := client.SendToRoute(ctx)
			if err != nil {
				closeClient()
				return nil, nil, nil, err
			}
			return &receiver{
					recv: func() (proto.Message, error) {
						return stream.Recv()
					},
				},
				&sender{
					send: func(req proto.Message) error {
						r := req.(*lnrpc.SendToRouteRequest)
						return stream.Send(r)
					},
					closeStream: stream.CloseSend,
				}, closeClient, nil
		},
	}
	return b.start(rStream)
}

// SendToRouteSync is a synchronous version of SendToRoute. It Will block
// until the payment either fails or succeeds.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func SendToRouteSync(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.SendToRouteRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.SendToRouteRequest)
			return client.SendToRouteSync(ctx, r)
		},
	}
	s.start(msg, callback)
}

// AddInvoice attempts to add a new invoice to the invoice database. Any
// duplicated invoices are rejected, therefore all invoices *must* have a
// unique payment preimage.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func AddInvoice(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.Invoice{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.Invoice)
			return client.AddInvoice(ctx, r)
		},
	}
	s.start(msg, callback)
}

// ListInvoices returns a list of all the invoices currently stored within the
// database. Any active debug invoices are ignored. It has full support for
// paginated responses, allowing users to query for specific invoices through
// their add_index. This can be done by using either the first_index_offset or
// last_index_offset fields included in the response as the index_offset of the
// next request. By default, the first 100 invoices created will be returned.
// Backwards pagination is also supported through the Reversed flag.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func ListInvoices(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.ListInvoiceRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.ListInvoiceRequest)
			return client.ListInvoices(ctx, r)
		},
	}
	s.start(msg, callback)
}

// LookupInvoice attempts to look up an invoice according to its payment hash.
// The passed payment hash *must* be exactly 32 bytes, if not, an error is
// returned.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func LookupInvoice(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.PaymentHash{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.PaymentHash)
			return client.LookupInvoice(ctx, r)
		},
	}
	s.start(msg, callback)
}

// SubscribeInvoices returns a uni-directional stream (server -> client) for
// notifying the client of newly added/settled invoices. The caller can
// optionally specify the add_index and/or the settle_index. If the add_index
// is specified, then we'll first start by sending add invoice events for all
// invoices with an add_index greater than the specified value. If the
// settle_index is specified, then next, we'll send out all settle events for
// invoices with a settle_index greater than the specified value. One or both
// of these fields can be set. If no fields are set, then we'll only send out
// the latest add/settle events.
//
// NOTE: This method produces a stream of responses, and the receive stream can
// be called zero or more times. After EOF error is returned, no more responses
// will be produced.
func SubscribeInvoices(msg []byte, rStream RecvStream) {
	s := &readStreamHandler{
		newProto: func() proto.Message {
			return &lnrpc.InvoiceSubscription{}
		},
		recvStream: func(ctx context.Context,
			req proto.Message) (*receiver, func(), error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, nil, err
			}

			r := req.(*lnrpc.InvoiceSubscription)
			stream, err := client.SubscribeInvoices(ctx, r)
			if err != nil {
				closeClient()
				return nil, nil, err
			}
			return &receiver{
				recv: func() (proto.Message, error) {
					return stream.Recv()
				},
			}, closeClient, nil
		},
	}
	s.start(msg, rStream)
}

// DecodePayReq takes an encoded payment request string and attempts to decode
// it, returning a full description of the conditions encoded within the
// payment request.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func DecodePayReq(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.PayReqString{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.PayReqString)
			return client.DecodePayReq(ctx, r)
		},
	}
	s.start(msg, callback)
}

// ListPayments returns a list of all outgoing payments.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func ListPayments(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.ListPaymentsRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.ListPaymentsRequest)
			return client.ListPayments(ctx, r)
		},
	}
	s.start(msg, callback)
}

// DeletePayment deletes an outgoing payment from DB. Note that it will not
// attempt to delete an In-Flight payment, since that would be unsafe.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func DeletePayment(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.DeletePaymentRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.DeletePaymentRequest)
			return client.DeletePayment(ctx, r)
		},
	}
	s.start(msg, callback)
}

// DeleteAllPayments deletes all outgoing payments from DB. Note that it will
// not attempt to delete In-Flight payments, since that would be unsafe.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func DeleteAllPayments(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.DeleteAllPaymentsRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.DeleteAllPaymentsRequest)
			return client.DeleteAllPayments(ctx, r)
		},
	}
	s.start(msg, callback)
}

// DescribeGraph returns a description of the latest graph state from the
// point of view of the node. The graph information is partitioned into two
// components: all the nodes/vertexes, and all the edges that connect the
// vertexes themselves. As this is a directed graph, the edges also contain
// the node directional specific routing policy which includes: the time lock
// delta, fee information, etc.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func DescribeGraph(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.ChannelGraphRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.ChannelGraphRequest)
			return client.DescribeGraph(ctx, r)
		},
	}
	s.start(msg, callback)
}

// GetNodeMetrics returns node metrics calculated from the graph. Currently
// the only supported metric is betweenness centrality of individual nodes.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func GetNodeMetrics(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.NodeMetricsRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.NodeMetricsRequest)
			return client.GetNodeMetrics(ctx, r)
		},
	}
	s.start(msg, callback)
}

// GetChanInfo returns the latest authenticated network announcement for the
// given channel identified by its channel ID: an 8-byte integer which
// uniquely identifies the location of transaction's funding output within the
// blockchain.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func GetChanInfo(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.ChanInfoRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.ChanInfoRequest)
			return client.GetChanInfo(ctx, r)
		},
	}
	s.start(msg, callback)
}

// GetNodeInfo returns the latest advertised, aggregated, and authenticated
// channel information for the specified node identified by its public key.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func GetNodeInfo(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.NodeInfoRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.NodeInfoRequest)
			return client.GetNodeInfo(ctx, r)
		},
	}
	s.start(msg, callback)
}

// QueryRoutes attempts to query the daemon's Channel Router for a possible
// route to a target destination capable of carrying a specific amount of
// satoshis. The returned route contains the full details required to craft and
// send an HTLC, also including the necessary information that should be
// present within the Sphinx packet encapsulated within the HTLC.
//
// When using REST, the `dest_custom_records` map type can be set by appending
// `&dest_custom_records[<record_number>]=<record_data_base64_url_encoded>`
// to the URL. Unfortunately this map type doesn't appear in the REST API
// documentation because of a bug in the grpc-gateway library.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func QueryRoutes(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.QueryRoutesRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.QueryRoutesRequest)
			return client.QueryRoutes(ctx, r)
		},
	}
	s.start(msg, callback)
}

// GetNetworkInfo returns some basic stats about the known channel graph from
// the point of view of the node.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func GetNetworkInfo(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.NetworkInfoRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.NetworkInfoRequest)
			return client.GetNetworkInfo(ctx, r)
		},
	}
	s.start(msg, callback)
}

// StopDaemon will send a shutdown request to the interrupt handler, triggering
// a graceful shutdown of the daemon.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func StopDaemon(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.StopRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.StopRequest)
			return client.StopDaemon(ctx, r)
		},
	}
	s.start(msg, callback)
}

// SubscribeChannelGraph launches a streaming RPC that allows the caller to
// receive notifications upon any changes to the channel graph topology from
// the point of view of the responding node. Events notified include: new
// nodes coming online, nodes updating their authenticated attributes, new
// channels being advertised, updates in the routing policy for a directional
// channel edge, and when channels are closed on-chain.
//
// NOTE: This method produces a stream of responses, and the receive stream can
// be called zero or more times. After EOF error is returned, no more responses
// will be produced.
func SubscribeChannelGraph(msg []byte, rStream RecvStream) {
	s := &readStreamHandler{
		newProto: func() proto.Message {
			return &lnrpc.GraphTopologySubscription{}
		},
		recvStream: func(ctx context.Context,
			req proto.Message) (*receiver, func(), error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, nil, err
			}

			r := req.(*lnrpc.GraphTopologySubscription)
			stream, err := client.SubscribeChannelGraph(ctx, r)
			if err != nil {
				closeClient()
				return nil, nil, err
			}
			return &receiver{
				recv: func() (proto.Message, error) {
					return stream.Recv()
				},
			}, closeClient, nil
		},
	}
	s.start(msg, rStream)
}

// DebugLevel allows a caller to programmatically set the logging verbosity of
// lnd. The logging can be targeted according to a coarse daemon-wide logging
// level, or in a granular fashion to specify the logging for a target
// sub-system.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func DebugLevel(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.DebugLevelRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.DebugLevelRequest)
			return client.DebugLevel(ctx, r)
		},
	}
	s.start(msg, callback)
}

// FeeReport allows the caller to obtain a report detailing the current fee
// schedule enforced by the node globally for each channel.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func FeeReport(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.FeeReportRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.FeeReportRequest)
			return client.FeeReport(ctx, r)
		},
	}
	s.start(msg, callback)
}

// UpdateChannelPolicy allows the caller to update the fee schedule and
// channel policies for all channels globally, or a particular channel.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func UpdateChannelPolicy(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.PolicyUpdateRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.PolicyUpdateRequest)
			return client.UpdateChannelPolicy(ctx, r)
		},
	}
	s.start(msg, callback)
}

// ForwardingHistory allows the caller to query the htlcswitch for a record of
// all HTLCs forwarded within the target time range, and integer offset
// within that time range, for a maximum number of events. If no maximum number
// of events is specified, up to 100 events will be returned. If no time-range
// is specified, then events will be returned in the order that they occured.
//
// A list of forwarding events are returned. The size of each forwarding event
// is 40 bytes, and the max message size able to be returned in gRPC is 4 MiB.
// As a result each message can only contain 50k entries. Each response has
// the index offset of the last entry. The index offset can be provided to the
// request to allow the caller to skip a series of records.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func ForwardingHistory(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.ForwardingHistoryRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.ForwardingHistoryRequest)
			return client.ForwardingHistory(ctx, r)
		},
	}
	s.start(msg, callback)
}

// ExportChannelBackup attempts to return an encrypted static channel backup
// for the target channel identified by it channel point. The backup is
// encrypted with a key generated from the aezeed seed of the user. The
// returned backup can either be restored using the RestoreChannelBackup
// method once lnd is running, or via the InitWallet and UnlockWallet methods
// from the WalletUnlocker service.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func ExportChannelBackup(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.ExportChannelBackupRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.ExportChannelBackupRequest)
			return client.ExportChannelBackup(ctx, r)
		},
	}
	s.start(msg, callback)
}

// ExportAllChannelBackups returns static channel backups for all existing
// channels known to lnd. A set of regular singular static channel backups for
// each channel are returned. Additionally, a multi-channel backup is returned
// as well, which contains a single encrypted blob containing the backups of
// each channel.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func ExportAllChannelBackups(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.ChanBackupExportRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.ChanBackupExportRequest)
			return client.ExportAllChannelBackups(ctx, r)
		},
	}
	s.start(msg, callback)
}

// VerifyChanBackup allows a caller to verify the integrity of a channel backup
// snapshot. This method will accept either a packed Single or a packed Multi.
// Specifying both will result in an error.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func VerifyChanBackup(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.ChanBackupSnapshot{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.ChanBackupSnapshot)
			return client.VerifyChanBackup(ctx, r)
		},
	}
	s.start(msg, callback)
}

// RestoreChannelBackups accepts a set of singular channel backups, or a
// single encrypted multi-chan backup and attempts to recover any funds
// remaining within the channel. If we are able to unpack the backup, then the
// new channel will be shown under listchannels, as well as pending channels.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func RestoreChannelBackups(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.RestoreChanBackupRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.RestoreChanBackupRequest)
			return client.RestoreChannelBackups(ctx, r)
		},
	}
	s.start(msg, callback)
}

// SubscribeChannelBackups allows a client to sub-subscribe to the most up to
// date information concerning the state of all channel backups. Each time a
// new channel is added, we return the new set of channels, along with a
// multi-chan backup containing the backup info for all channels. Each time a
// channel is closed, we send a new update, which contains new new chan back
// ups, but the updated set of encrypted multi-chan backups with the closed
// channel(s) removed.
//
// NOTE: This method produces a stream of responses, and the receive stream can
// be called zero or more times. After EOF error is returned, no more responses
// will be produced.
func SubscribeChannelBackups(msg []byte, rStream RecvStream) {
	s := &readStreamHandler{
		newProto: func() proto.Message {
			return &lnrpc.ChannelBackupSubscription{}
		},
		recvStream: func(ctx context.Context,
			req proto.Message) (*receiver, func(), error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, nil, err
			}

			r := req.(*lnrpc.ChannelBackupSubscription)
			stream, err := client.SubscribeChannelBackups(ctx, r)
			if err != nil {
				closeClient()
				return nil, nil, err
			}
			return &receiver{
				recv: func() (proto.Message, error) {
					return stream.Recv()
				},
			}, closeClient, nil
		},
	}
	s.start(msg, rStream)
}

// BakeMacaroon allows the creation of a new macaroon with custom read and
// write permissions. No first-party caveats are added since this can be done
// offline.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func BakeMacaroon(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.BakeMacaroonRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.BakeMacaroonRequest)
			return client.BakeMacaroon(ctx, r)
		},
	}
	s.start(msg, callback)
}

// ListMacaroonIDs returns all root key IDs that are in use.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func ListMacaroonIDs(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.ListMacaroonIDsRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.ListMacaroonIDsRequest)
			return client.ListMacaroonIDs(ctx, r)
		},
	}
	s.start(msg, callback)
}

// DeleteMacaroonID deletes the specified macaroon ID and invalidates all
// macaroons derived from that ID.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func DeleteMacaroonID(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.DeleteMacaroonIDRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.DeleteMacaroonIDRequest)
			return client.DeleteMacaroonID(ctx, r)
		},
	}
	s.start(msg, callback)
}

// ListPermissions lists all RPC method URIs and their required macaroon
// permissions to access them.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func ListPermissions(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.ListPermissionsRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.ListPermissionsRequest)
			return client.ListPermissions(ctx, r)
		},
	}
	s.start(msg, callback)
}

// CheckMacaroonPermissions checks whether a request follows the constraints
// imposed on the macaroon and that the macaroon is authorized to follow the
// provided permissions.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func CheckMacaroonPermissions(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.CheckMacPermRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.CheckMacPermRequest)
			return client.CheckMacaroonPermissions(ctx, r)
		},
	}
	s.start(msg, callback)
}

// RegisterRPCMiddleware adds a new gRPC middleware to the interceptor chain. A
// gRPC middleware is software component external to lnd that aims to add
// additional business logic to lnd by observing/intercepting/validating
// incoming gRPC client requests and (if needed) replacing/overwriting outgoing
// messages before they're sent to the client. When registering the middleware
// must identify itself and indicate what custom macaroon caveats it wants to
// be responsible for. Only requests that contain a macaroon with that specific
// custom caveat are then sent to the middleware for inspection. The other
// option is to register for the read-only mode in which all requests/responses
// are forwarded for interception to the middleware but the middleware is not
// allowed to modify any responses. As a security measure, _no_ middleware can
// modify responses for requests made with _unencumbered_ macaroons!
//
// NOTE: This method produces a stream of responses, and the receive stream can
// be called zero or more times. After EOF error is returned, no more responses
// will be produced. The send stream can accept zero or more requests before it
// is closed.
func RegisterRPCMiddleware(rStream RecvStream) (SendStream, error) {
	b := &biStreamHandler{
		newProto: func() proto.Message {
			return &lnrpc.RPCMiddlewareResponse{}
		},
		biStream: func(ctx context.Context) (*receiver, *sender, func(), error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, nil, nil, err
			}

			stream, err := client.RegisterRPCMiddleware(ctx)
			if err != nil {
				closeClient()
				return nil, nil, nil, err
			}
			return &receiver{
					recv: func() (proto.Message, error) {
						return stream.Recv()
					},
				},
				&sender{
					send: func(req proto.Message) error {
						r := req.(*lnrpc.RPCMiddlewareResponse)
						return stream.Send(r)
					},
					closeStream: stream.CloseSend,
				}, closeClient, nil
		},
	}
	return b.start(rStream)
}

// SendCustomMessage sends a custom peer message.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func SendCustomMessage(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.SendCustomMessageRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.SendCustomMessageRequest)
			return client.SendCustomMessage(ctx, r)
		},
	}
	s.start(msg, callback)
}

// SubscribeCustomMessages subscribes to a stream of incoming custom peer
// messages.
//
// To include messages with type outside of the custom range (>= 32768) lnd
// needs to be compiled with  the `dev` build tag, and the message type to
// override should be specified in lnd's experimental protocol configuration.
//
// NOTE: This method produces a stream of responses, and the receive stream can
// be called zero or more times. After EOF error is returned, no more responses
// will be produced.
func SubscribeCustomMessages(msg []byte, rStream RecvStream) {
	s := &readStreamHandler{
		newProto: func() proto.Message {
			return &lnrpc.SubscribeCustomMessagesRequest{}
		},
		recvStream: func(ctx context.Context,
			req proto.Message) (*receiver, func(), error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, nil, err
			}

			r := req.(*lnrpc.SubscribeCustomMessagesRequest)
			stream, err := client.SubscribeCustomMessages(ctx, r)
			if err != nil {
				closeClient()
				return nil, nil, err
			}
			return &receiver{
				recv: func() (proto.Message, error) {
					return stream.Recv()
				},
			}, closeClient, nil
		},
	}
	s.start(msg, rStream)
}

// ListAliases returns the set of all aliases that have ever existed with
// their confirmed SCID (if it exists) and/or the base SCID (in the case of
// zero conf).
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func ListAliases(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.ListAliasesRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.ListAliasesRequest)
			return client.ListAliases(ctx, r)
		},
	}
	s.start(msg, callback)
}

// LookupHtlcResolution retrieves a final htlc resolution from the database.
// If the htlc has no final resolution yet, a NotFound grpc status code is
// returned.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func LookupHtlcResolution(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &lnrpc.LookupHtlcResolutionRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getLightningClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*lnrpc.LookupHtlcResolutionRequest)
			return client.LookupHtlcResolution(ctx, r)
		},
	}
	s.start(msg, callback)
}
